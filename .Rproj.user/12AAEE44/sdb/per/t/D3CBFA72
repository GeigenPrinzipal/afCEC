{
    "contents" : "#define ARMA_DONT_PRINT_ERRORS\n#include <RcppArmadillo.h>\n// [[Rcpp::depends(RcppArmadillo)]]\n#include <iostream>\n#include <stdio.h>\n#include <stdlib.h>\n#include <mem.h>\n#include <string>\n#include <string.h>\n#include <math.h>\n#include <set>\n#include <map>\n#include <sstream>\n#include <cctype>\n#include <list>\n#include <vector>\n#include <stack>\n#include <deque>\n#include <fstream>\n\n#include \".\\CafCECHartigan.h\"\n#include \".\\Parser.h\"\n#include \".\\Utils.h\"\n\nusing namespace arma;\n\n//   -*-   -*-   -*-\n\nbool printErrorMessages = true;\n\nvoid DisableErrorMessages() {\n    printErrorMessages = false;\n}\n\nvoid EnableErrorMessages() {\n    printErrorMessages = true;\n}\n\n//   -*-   -*-   -*-\n\nunsigned seed = 0;\n\nvoid SetRNGSeed(unsigned newSeed) {\n    seed = newSeed;\n}\n\nint RandomInteger() {\n    unsigned prevSeed = seed;\n    seed = (1664525 * seed) + 1013904223;\n    return prevSeed;\n}\n\nfloat RandomFloat() {\n    float tmp;\n    *((unsigned *)&tmp) = (seed & 8388607) | 1065353216;\n    seed = (1664525 * seed) + 1013904223;\n    return tmp - 1.0f;\n}\n\n//   -*-   -*-   -*-\n\n/*bool CholeskyRankOneUpdate(mat &L, vec &v) {\n    double *vPtr = v.memptr();\n    for (int i = 0; i < L.n_rows; ++i) {\n        double *LPtr = L.colptr(i);\n        double r = sqrt((LPtr[i] * LPtr[i]) + (vPtr[i] * vPtr[i]));\n        double c = LPtr[i] / r;\n        double s = -vPtr[i] / r;\n        LPtr[i] = r;\n        for (int j = i + 1; j < L.n_cols; ++j) {\n            double tmp1 = (LPtr[j] * c) - (vPtr[j] * s);\n            double tmp2 = (LPtr[j] * s) + (vPtr[j] * c);\n            LPtr[j] = tmp1;\n            vPtr[j] = tmp2;\n        }\n    }\n    return true;\n}*/\n\n//   -*-   -*-   -*-\n\n/*bool CholeskyRankOneDowndate(mat &L, vec &v) {\n    double *vPtr = v.memptr();\n    for (int i = 0; i < L.n_rows; ++i) {\n        double *LPtr = L.colptr(i);\n        double r = sqrt((LPtr[i] * LPtr[i]) - (vPtr[i] * vPtr[i]));\n        double c = LPtr[i] / r;\n        double s = -vPtr[i] / r;\n        LPtr[i] = r;\n        for (int j = i + 1; j < L.n_cols; ++j) {\n            double tmp1 = (LPtr[j] * c) + (vPtr[j] * s);\n            double tmp2 = (LPtr[j] * s) + (vPtr[j] * c);\n            LPtr[j] = tmp1;\n            vPtr[j] = tmp2;\n        }\n    }\n    return true;\n}*/\n\n//   -*-   -*-   -*-\n\n// [[Rcpp::export]]\nstd::string GenerateCodeForArrayConstruction(std::string &formula) {\n    BuildTokensMaps();\n    std::vector<STokenInfo> tokens = Tokenize(formula);\n    int pos = 0;\n    aVarInd = 0;\n    std::string code;\n    int varRes; // !!!\n    ParseBody(tokens, pos, code, varRes);\n    std::stringstream ss;\n\n    ss << \"#include <RcppArmadillo.h>\" << std::endl;\n    ss << \"// [[Rcpp::depends(RcppArmadillo)]]\" << std::endl;\n    ss << std::endl;\n    ss << \"using namespace arma;\" << std::endl;\n    ss << std::endl;\n    ss << code;\n    ss << std::endl;\n    ss << \"// [[Rcpp::export]]\" << std::endl;\n    ss << \"arma::mat CalculateArrayOfValues(arma::mat &points) {\" << std::endl;\n    ss << \"    int pointsNum = points.n_cols;\" << std::endl;\n    ss << \"    int dim = points.n_rows;\" << std::endl;\n    ss << \"    vec tmp(dim);\" << std::endl;\n    ss << std::endl;\n    ss << \"    vec foo = f(tmp.submat(0, 0, dim - 2, 0)); // !!!\" << std::endl;\n    ss << \"    int numberOfComponents = foo.n_rows; // !!!\" << std::endl;\n    ss << std::endl;\n    ss << \"    mat values(dim * numberOfComponents, pointsNum);\" << std::endl;\n    ss << \"    for (int i = 0; i < pointsNum; ++i) {\" << std::endl;\n    ss << \"        tmp.submat(0, 0, dim - 2, 0) = points.submat(1, i, dim - 1, i);\" << std::endl;\n    ss << \"        for (int j = 0; j < dim; ++j) {\" << std::endl;\n    ss << \"            values.submat(j * numberOfComponents, i, ((j + 1) * numberOfComponents) - 1, i) = f(tmp.submat(0, 0, dim - 2, 0));\" << std::endl;\n    ss << \"            tmp(j) = points(j, i);\" << std::endl;\n    ss << \"        }\" << std::endl;\n    ss << \"    }\" << std::endl;\n    ss << \"    return values;\" << std::endl;\n    ss << \"}\" << std::endl;\n\n    return ss.str();\n}\n\n//   -*-   -*-   -*-\n\n// [[Rcpp::export]]\nvoid UpdateMeansForQuadraticFunction(Rcpp::List &res) {\n    Rcpp::List mL = res[\"means\"];\n    Rcpp::List dirsL = res[\"directions\"];\n    Rcpp::List coeffsL = res[\"coefficients\"];\n    int maxClusters = mL.length();\n    for (int i = 0; i < maxClusters; ++i) {\n        if (mL[i] != R_NilValue) {\n            vec m = mL[i];\n            int dir = dirsL[i];\n            vec coeffs = coeffsL[i];\n            vec tmp(m.n_elem - 1);\n            if (dir > 0) tmp.subvec(0, dir - 1) = m.subvec(0, dir - 1);\n            if (dir < m.n_elem - 1) tmp.subvec(dir, m.n_elem - 2) = m.subvec(dir + 1, m.n_elem - 1);\n            double value = 0.0;\n            for (int k = 0; k < (coeffs.n_elem - 1) / 2; ++k) {\n                value += coeffs(k) * tmp(k) * tmp(k);\n                value += coeffs(((coeffs.n_elem - 1) / 2) + k) * tmp(k);\n            }\n            value += coeffs(coeffs.n_elem - 1);\n            m[dir] = value;\n            mL[i] = m;\n        }\n    }\n    res[\"means\"] = mL;\n}\n\n//   -*-   -*-   -*-\n\n// [[Rcpp::export]]\nstd::string GenerateCodeForUpdatingMeans(std::string &formula) {\n    BuildTokensMaps();\n    std::vector<STokenInfo> tokens = Tokenize(formula);\n    int pos = 0;\n    aVarInd = 0;\n    std::string code;\n    int varRes; // !!!\n    ParseBody(tokens, pos, code, varRes);\n    std::stringstream ss;\n\n    ss << \"#include <RcppArmadillo.h>\" << std::endl;\n    ss << \"// [[Rcpp::depends(RcppArmadillo)]]\" << std::endl;\n    ss << std::endl;\n    ss << \"using namespace arma;\" << std::endl;\n    ss << std::endl;\n    ss << code;\n    ss << std::endl;\n    ss << \"// [[Rcpp::export]]\" << std::endl;\n    ss << \"void UpdateMeans(Rcpp::List &res) {\" << std::endl;\n    ss << \"    Rcpp::List mL = res[\\\"means\\\"];\" << std::endl;\n    ss << \"    Rcpp::List dirsL = res[\\\"directions\\\"];\" << std::endl;\n    ss << \"    Rcpp::List coeffsL = res[\\\"coefficients\\\"];\" << std::endl;\n    ss << \"    int maxClusters = mL.length();\" << std::endl;\n    ss << \"    for (int i = 0; i < maxClusters; ++i) {\" << std::endl;\n    ss << \"        if (mL[i] != R_NilValue) {\" << std::endl;\n    ss << \"            vec m = mL[i];\" << std::endl;\n    ss << \"            int dir = dirsL[i];\" << std::endl;\n    ss << \"            vec coeffs = coeffsL[i];\" << std::endl;\n    ss << \"            vec tmp(m.n_elem - 1);\" << std::endl;\n    ss << \"            if (dir > 0) tmp.subvec(0, dir - 1) = m.subvec(0, dir - 1);\" << std::endl;\n    ss << \"            if (dir < m.n_elem - 1) tmp.subvec(dir, m.n_elem - 2) = m.subvec(dir + 1, m.n_elem - 1);\" << std::endl;\n    ss << \"            vec values = f(tmp);\" << std::endl;\n    ss << \"            double value = 0.0;\" << std::endl;\n    ss << \"            for (int k = 0; k < coeffs.n_elem; ++k) value += coeffs(k) * values(k);\" << std::endl;\n    ss << \"            m[dir] = value;\" << std::endl;\n    ss << \"            mL[i] = m;\" << std::endl;\n    ss << \"        }\" << std::endl;\n    ss << \"    }\" << std::endl;\n    ss << \"    res[\\\"means\\\"] = mL;\" << std::endl;\n    ss << \"}\" << std::endl;\n\n    return ss.str();\n}\n\n//   -*-   -*-   -*-\n\n// [[Rcpp::export]]\nRcpp::List CalculateEllipsesOfConfidenceForQuadraticFunction(Rcpp::List res, double confidence, int segments) {\n    Rcpp::List covsL = res[\"covariances\"];\n    Rcpp::List mL = res[\"means\"];\n    Rcpp::List dirsL = res[\"directions\"];\n    Rcpp::List coeffsL = res[\"coefficients\"];\n    int maxClusters = covsL.length();\n    Rcpp::List ellipsesL(maxClusters);\n    Rcpp::List axesL(maxClusters);\n    for (int i = 0; i < maxClusters; ++i) {\n        if (covsL[i] != R_NilValue) {\n            mat cov = covsL[i];\n            vec m = mL[i];\n            int dir = dirsL[i];\n            vec coeffs = coeffsL[i];\n            mat points(segments + 1, 2);\n            double lambda1 = cov(0, 0);\n            double lambda2 = cov(1, 1);\n            vec eAxes(2);\n            eAxes(0) = sqrt(lambda1 * R::qchisq(confidence, 2, 1, 0));\n            eAxes(1) = sqrt(lambda2 * R::qchisq(confidence, 2, 1, 0));\n            for (int j = 0; j < segments; ++j) {\n                double x = eAxes(0) * cos(((2.0 * M_PI) / segments) * j);\n                double y = eAxes(1) * sin(((2.0 * M_PI) / segments) * j);\n                points(j, 0) = x;\n                points(j, 1) = y;\n                points(j, (dir + 1) & 1) += m((dir + 1) & 1);\n                double tmp = points(j, (dir + 1) & 1);\n                double value = (coeffs(0) * tmp * tmp) + (coeffs(1) * tmp) + coeffs(2);\n                points(j, dir) += value;\n            }\n            points(segments, 0) = points(0, 0);\n            points(segments, 1) = points(0, 1);\n            ellipsesL[i] = points;\n            for (int j = 0; j <= segments; ++j) {\n                points(j, (dir + 1) & 1) = -eAxes((dir + 1) & 1) + (((2.0 * eAxes((dir + 1) & 1)) / segments) * j) + m((dir + 1) & 1);\n                double tmp = points(j, (dir + 1) & 1);\n                double value = (coeffs(0) * tmp * tmp) + (coeffs(1) * tmp) + coeffs(2);\n                points(j, dir) = value;\n            }\n            axesL[i] = points;\n        } else {\n            ellipsesL[i] = R_NilValue;\n            axesL[i] = R_NilValue;\n        }\n    };\n    return Rcpp::List::create(ellipsesL, axesL);\n}\n\n//   -*-   -*-   -*-\n\n// [[Rcpp::export]]\nstd::string GenerateCodeForCalculatingEllipsesOfConfidence(std::string &formula) {\n    BuildTokensMaps();\n    std::vector<STokenInfo> tokens = Tokenize(formula);\n    int pos = 0;\n    aVarInd = 0;\n    std::string code;\n    int varRes; // !!!\n    ParseBody(tokens, pos, code, varRes);\n    std::stringstream ss;\n\n    ss << \"#include <RcppArmadillo.h>\" << std::endl;\n    ss << \"// [[Rcpp::depends(RcppArmadillo)]]\" << std::endl;\n    ss << std::endl;\n    ss << \"using namespace arma;\" << std::endl;\n    ss << std::endl;\n    ss << code;\n    ss << std::endl;\n    ss << \"// [[Rcpp::export]]\" << std::endl;\n    ss << \"Rcpp::List CalculateEllipsesOfConfidence(Rcpp::List res, double confidence, int segments) {\" << std::endl;\n    ss << \"    Rcpp::List covsL = res[\\\"covariances\\\"];\" << std::endl;\n    ss << \"    Rcpp::List mL = res[\\\"means\\\"];\" << std::endl;\n    ss << \"    Rcpp::List dirsL = res[\\\"directions\\\"];\" << std::endl;\n    ss << \"    Rcpp::List coeffsL = res[\\\"coefficients\\\"];\" << std::endl;\n    ss << \"    int maxClusters = covsL.length();\" << std::endl;\n    ss << \"    Rcpp::List ellipsesL(maxClusters);\" << std::endl;\n    ss << \"    Rcpp::List axesL(maxClusters);\" << std::endl;\n    ss << \"    for (int i = 0; i < maxClusters; ++i) {\" << std::endl;\n    ss << \"        if (covsL[i] != R_NilValue) {\" << std::endl;\n    ss << \"            mat cov = covsL[i];\" << std::endl;\n    ss << \"            vec m = mL[i];\" << std::endl;\n    ss << \"            int dir = dirsL[i];\" << std::endl;\n    ss << \"            vec coeffs = coeffsL[i];\" << std::endl;\n    ss << \"            mat points(segments + 1, 2);\" << std::endl;\n    ss << \"            double lambda1 = cov(0, 0);\" << std::endl;\n    ss << \"            double lambda2 = cov(1, 1);\" << std::endl;\n    ss << \"            vec eAxes(2);\" << std::endl;\n    ss << \"            eAxes(0) = sqrt(lambda1 * R::qchisq(confidence, 2, 1, 0));\" << std::endl;\n    ss << \"            eAxes(1) = sqrt(lambda2 * R::qchisq(confidence, 2, 1, 0));\" << std::endl;\n    ss << \"            for (int j = 0; j < segments; ++j) {\" << std::endl;\n    ss << \"                double x = eAxes(0) * cos(((2.0 * M_PI) / segments) * j);\" << std::endl;\n    ss << \"                double y = eAxes(1) * sin(((2.0 * M_PI) / segments) * j);\" << std::endl;\n    ss << \"                points(j, 0) = x;\" << std::endl;\n    ss << \"                points(j, 1) = y;\" << std::endl;\n    ss << \"                points(j, (dir + 1) & 1) += m((dir + 1) & 1);\" << std::endl;\n    ss << \"                vec tmp(1);\" << std::endl;\n    ss << \"                tmp(0) = points(j, (dir + 1) & 1);\" << std::endl;\n    ss << \"                vec values = f(tmp);\" << std::endl;\n    ss << \"                double value = 0.0;\" << std::endl;\n    ss << \"                for (int k = 0; k < coeffs.n_elem; ++k) value += coeffs(k) * values(k);\" << std::endl;\n    ss << \"                points(j, dir) += value;\" << std::endl;\n    ss << \"            }\" << std::endl;\n    ss << \"            points(segments, 0) = points(0, 0);\" << std::endl;\n    ss << \"            points(segments, 1) = points(0, 1);\" << std::endl;\n    ss << \"            ellipsesL[i] = points;\" << std::endl;\n    ss << \"            for (int j = 0; j <= segments; ++j) {\" << std::endl;\n    ss << \"                points(j, (dir + 1) & 1) = -eAxes((dir + 1) & 1) + (((2.0 * eAxes((dir + 1) & 1)) / segments) * j) + m((dir + 1) & 1);\" << std::endl;\n    ss << \"                vec tmp(1);\" << std::endl;\n    ss << \"                tmp(0) = points(j, (dir + 1) & 1);\" << std::endl;\n    ss << \"                vec values = f(tmp);\" << std::endl;\n    ss << \"                double value = 0.0;\" << std::endl;\n    ss << \"                for (int k = 0; k < coeffs.n_elem; ++k) value += coeffs(k) * values(k);\" << std::endl;\n    ss << \"                points(j, dir) = value;\" << std::endl;\n    ss << \"            }\" << std::endl;\n    ss << \"            axesL[i] = points;\" << std::endl;\n    ss << \"        } else {\" << std::endl;\n    ss << \"            ellipsesL[i] = R_NilValue;\" << std::endl;\n    ss << \"            axesL[i] = R_NilValue;\" << std::endl;\n    ss << \"        }\" << std::endl;\n    ss << \"    }\" << std::endl;\n    ss << \"    return Rcpp::List::create(ellipsesL, axesL);\" << std::endl;\n    ss << \"}\" << std::endl;\n\n    return ss.str();\n}\n\n//   -*-   -*-   -*-\n\n// [[Rcpp::export]]\nRcpp::List CalculateEllipsoidsOfConfidenceForQuadraticFunction(Rcpp::List res, double confidence, int gridRes) {\n    Rcpp::List covsL = res[\"covariances\"];\n    Rcpp::List mL = res[\"means\"];\n    Rcpp::List dirsL = res[\"directions\"];\n    Rcpp::List coeffsL = res[\"coefficients\"];\n    int maxClusters = covsL.length();\n    Rcpp::List ellipsoidsL(maxClusters);\n    Rcpp::List ellipsoidsNL(maxClusters);\n    Rcpp::List ellipsoidsML(maxClusters);\n    Rcpp::List ellipsoidsMNL(maxClusters);\n    for (int i = 0; i < maxClusters; ++i) {\n        if (covsL[i] != R_NilValue) {\n            vec eigval;\n            mat eigvec;\n            mat cov = covsL[i];\n            eig_sym(eigval, eigvec, cov);\n            double percentile = R::qchisq(confidence, 3, 1, 0);\n            vec eAxes(3);\n            for (int j = 0; j < 3; ++j) eAxes(j) = sqrt(eigval(j) * percentile);\n            vec m = mL[i];\n            int dir = dirsL[i];\n            vec coeffs = coeffsL[i];\n\n            mat verts(2 + ((gridRes - 1) * gridRes), 3);\n            verts(0, 0) = 0.0; verts(0, 1) = 0.0; verts(0, 2) = eAxes(2);\n            for (int j = 1; j < gridRes; ++j) {\n                for (int k = 0; k < gridRes; ++k) {\n                    verts(1 + ((j - 1) * gridRes) + k, 0) = eAxes(0) * sin((M_PI / gridRes) * j) * cos(((2 * M_PI) / gridRes) * k);\n                    verts(1 + ((j - 1) * gridRes) + k, 1) = eAxes(1) * sin((M_PI / gridRes) * j) * sin(((2 * M_PI) / gridRes) * k);\n                    verts(1 + ((j - 1) * gridRes) + k, 2) = eAxes(2) * cos((M_PI / gridRes) * j);\n                }\n            }\n            verts(1 + ((gridRes - 1) * gridRes), 0) = 0.0;\n            verts(1 + ((gridRes - 1) * gridRes), 1) = 0.0;\n            verts(1 + ((gridRes - 1) * gridRes), 2) = -eAxes(2);\n\n            verts = (eigvec * verts.t()).t();\n            for (int j = 0; j < verts.n_rows; ++j) {\n                vec tmp = verts.row(j).t();\n                for (int k = 0; k < 3; ++k) {\n                    if (k != dir) tmp(k) += m(k);\n                }\n                verts.row(j) = tmp.t();\n                tmp.shed_row(dir);\n                double value = (coeffs(0) * tmp(0) * tmp(0)) + (coeffs(1) * tmp(1) * tmp(1)) +\n                    (coeffs(2) * tmp(0)) + (coeffs(3) * tmp(1)) +\n                    coeffs(4);\n                verts(j, dir) += value;\n            }\n\n            umat faces((gridRes * 2) + (((gridRes - 2) * gridRes) * 2), 3);\n            for (int j = 0; j < gridRes; ++j) {\n                faces(j, 0) = 0;\n                faces(j, 1) = 1 + ((j + 1) % gridRes);\n                faces(j, 2) = 1 + j;\n            }\n            for (int j = 0; j < gridRes - 2; ++j) {\n                for (int k = 0; k < gridRes; ++k) {\n                    faces(gridRes + (((j * gridRes) + k) * 2), 0) = 1 + (j * gridRes) + k;\n                    faces(gridRes + (((j * gridRes) + k) * 2), 1) = 1 + (j * gridRes) + ((k + 1) % gridRes);\n                    faces(gridRes + (((j * gridRes) + k) * 2), 2) = 1 + ((j + 1) * gridRes) + ((k + 1) % gridRes);\n                    faces(gridRes + (((j * gridRes) + k) * 2) + 1, 0) = 1 + (j * gridRes) + k;\n                    faces(gridRes + (((j * gridRes) + k) * 2) + 1, 1) = 1 + ((j + 1) * gridRes) + ((k + 1) % gridRes);\n                    faces(gridRes + (((j * gridRes) + k) * 2) + 1, 2) = 1 + ((j + 1) * gridRes) + k;\n                }\n            }\n            for (int j = 0; j < gridRes; ++j) {\n                faces(gridRes + (((gridRes - 2) * gridRes) * 2) + j, 0) = 1 + ((gridRes - 2) * gridRes) + j;\n                faces(gridRes + (((gridRes - 2) * gridRes) * 2) + j, 1) = 1 + ((gridRes - 2) * gridRes) + ((j + 1) % gridRes);\n                faces(gridRes + (((gridRes - 2) * gridRes) * 2) + j, 2) = 1 + ((gridRes - 1) * gridRes);\n            }\n\n            mat fNormals(faces.n_rows, 3);\n            for (int j = 0; j < faces.n_rows; ++j) {\n                unsigned i1 = faces(j, 0);\n                unsigned i2 = faces(j, 1);\n                unsigned i3 = faces(j, 2);\n                vec v1 = verts.row(i1).t();\n                vec v2 = verts.row(i2).t();\n                vec v3 = verts.row(i3).t();\n                vec N = normalise(cross(v2 - v1, v3 - v1));\n                fNormals.row(j) = N.t();\n            }\n\n            mat vNormals(verts.n_rows, 3, fill::zeros);\n            for (int j = 0; j < faces.n_rows; ++j) {\n                unsigned i1 = faces(j, 0);\n                unsigned i2 = faces(j, 1);\n                unsigned i3 = faces(j, 2);\n                vNormals.row(i1) += fNormals.row(j);\n                vNormals.row(i2) += fNormals.row(j);\n                vNormals.row(i3) += fNormals.row(j);\n            }\n\n            for (int j = 0; j < vNormals.n_rows; ++j) vNormals.row(j) = normalise(vNormals.row(j));\n\n            mat eFaces(faces.n_rows * 3, 3);\n            mat eNormals(faces.n_rows * 3, 3);\n            for (int j = 0; j < faces.n_rows; ++j) {\n                unsigned i1 = faces(j, 0);\n                unsigned i2 = faces(j, 1);\n                unsigned i3 = faces(j, 2);\n                eFaces.row(j * 3) = verts.row(i1);\n                eFaces.row((j * 3) + 1) = verts.row(i2);\n                eFaces.row((j * 3) + 2) = verts.row(i3);\n                eNormals.row(j * 3) = vNormals.row(i1);\n                eNormals.row((j * 3) + 1) = vNormals.row(i2);\n                eNormals.row((j * 3) + 2) = vNormals.row(i3);\n            }\n\n            ellipsoidsL[i] = eFaces;\n            ellipsoidsNL[i] = eNormals;\n\n            cov.shed_row(dir);\n            cov.shed_col(dir);\n            eig_sym(eigval, eigvec, cov);\n            for (int j = 0; j < 2; ++j) eAxes(j) = sqrt(eigval(j) * percentile);\n\n            mat vertsM(1 + (gridRes * gridRes), 2);\n            verts(0, 0) = 0.0; verts(0, 1) = 0.0;\n            for (int j = 1; j <= gridRes; ++j) {\n                for (int k = 0; k < gridRes; ++k) {\n                    vertsM(1 + ((j - 1) * gridRes) + k, 0) = ((eAxes(0) / gridRes) * j) * cos(((2 * M_PI) / gridRes) * k);\n                    vertsM(1 + ((j - 1) * gridRes) + k, 1) = ((eAxes(1) / gridRes) * j) * sin(((2 * M_PI) / gridRes) * k);\n                }\n            }\n\n            vertsM = (eigvec * vertsM.t()).t();\n            vertsM.insert_cols(dir, 1, true);\n            for (int j = 0; j < vertsM.n_rows; ++j) {\n                vec tmp = vertsM.row(j).t();\n                for (int k = 0; k < 3; ++k) {\n                    if (k != dir) tmp(k) += m(k);\n                }\n                vertsM.row(j) = tmp.t();\n                tmp.shed_row(dir);\n                double value = (coeffs(0) * tmp(0) * tmp(0)) + (coeffs(1) * tmp(1) * tmp(1)) +\n                    (coeffs(2) * tmp(0)) + (coeffs(3) * tmp(1)) +\n                    coeffs(4);\n                vertsM(j, dir) += value;\n            }\n\n            umat facesM(gridRes + (((gridRes - 1) * gridRes) * 2), 3);\n            for (int j = 0; j < gridRes; ++j) {\n                facesM(j, 0) = 0;\n                facesM(j, 1) = 1 + ((j + 1) % gridRes);\n                facesM(j, 2) = 1 + j;\n            }\n            for (int j = 0; j < gridRes - 1; ++j) {\n                for (int k = 0; k < gridRes; ++k) {\n                    facesM(gridRes + (((j * gridRes) + k) * 2), 0) = 1 + (j * gridRes) + k;\n                    facesM(gridRes + (((j * gridRes) + k) * 2), 1) = 1 + (j * gridRes) + ((k + 1) % gridRes);\n                    facesM(gridRes + (((j * gridRes) + k) * 2), 2) = 1 + ((j + 1) * gridRes) + ((k + 1) % gridRes);\n                    facesM(gridRes + (((j * gridRes) + k) * 2) + 1, 0) = 1 + (j * gridRes) + k;\n                    facesM(gridRes + (((j * gridRes) + k) * 2) + 1, 1) = 1 + ((j + 1) * gridRes) + ((k + 1) % gridRes);\n                    facesM(gridRes + (((j * gridRes) + k) * 2) + 1, 2) = 1 + ((j + 1) * gridRes) + k;\n                }\n            }\n\n            mat fNormalsM(facesM.n_rows, 3);\n            for (int j = 0; j < facesM.n_rows; ++j) {\n                unsigned i1 = facesM(j, 0);\n                unsigned i2 = facesM(j, 1);\n                unsigned i3 = facesM(j, 2);\n                vec v1 = vertsM.row(i1).t();\n                vec v2 = vertsM.row(i2).t();\n                vec v3 = vertsM.row(i3).t();\n                vec N = normalise(cross(v2 - v1, v3 - v1));\n                fNormalsM.row(j) = N.t();\n            };\n\n            mat vNormalsM(vertsM.n_rows, 3, fill::zeros);\n            for (int j = 0; j < facesM.n_rows; ++j) {\n                unsigned i1 = facesM(j, 0);\n                unsigned i2 = facesM(j, 1);\n                unsigned i3 = facesM(j, 2);\n                vNormalsM.row(i1) += fNormalsM.row(j);\n                vNormalsM.row(i2) += fNormalsM.row(j);\n                vNormalsM.row(i3) += fNormalsM.row(j);\n            }\n\n            for (int j = 0; j < vNormalsM.n_rows; ++j) vNormalsM.row(j) = normalise(vNormalsM.row(j));\n\n            mat eMFaces(facesM.n_rows * 3, 3);\n            mat eMNormals(facesM.n_rows * 3, 3);\n            for (int j = 0; j < facesM.n_rows; ++j) {\n                unsigned i1 = facesM(j, 0);\n                unsigned i2 = facesM(j, 1);\n                unsigned i3 = facesM(j, 2);\n                eMFaces.row(j * 3) = vertsM.row(i1);\n                eMFaces.row((j * 3) + 1) = vertsM.row(i2);\n                eMFaces.row((j * 3) + 2) = vertsM.row(i3);\n                eMNormals.row(j * 3) = vNormalsM.row(i1);\n                eMNormals.row((j * 3) + 1) = vNormalsM.row(i2);\n                eMNormals.row((j * 3) + 2) = vNormalsM.row(i3);\n            }\n\n            ellipsoidsML[i] = eMFaces;\n            ellipsoidsMNL[i] = eMNormals;\n        } else {\n            ellipsoidsL[i] = R_NilValue;\n            ellipsoidsNL[i] = R_NilValue;\n            ellipsoidsML[i] = R_NilValue;\n            ellipsoidsMNL[i] = R_NilValue;\n        }\n    }\n    return Rcpp::List::create(ellipsoidsL, ellipsoidsNL, ellipsoidsML, ellipsoidsMNL);\n}\n\n//   -*-   -*-   -*-\n\n// [[Rcpp::export]]\nstd::string GenerateCodeForCalculatingEllipsoidsOfConfidence(std::string &formula) {\n    BuildTokensMaps();\n    std::vector<STokenInfo> tokens = Tokenize(formula);\n    int pos = 0;\n    aVarInd = 0;\n    std::string code;\n    int varRes; // !!!\n    ParseBody(tokens, pos, code, varRes);\n    std::stringstream ss;\n\n    ss << \"#include <RcppArmadillo.h>\" << std::endl;\n    ss << \"// [[Rcpp::depends(RcppArmadillo)]]\" << std::endl;\n    ss << std::endl;\n    ss << \"using namespace arma;\" << std::endl;\n    ss << std::endl;\n    ss << code;\n    ss << std::endl;\n    ss << \"// [[Rcpp::export]]\" << std::endl;\n    ss << \"Rcpp::List CalculateEllipsoidsOfConfidence(Rcpp::List res, double confidence, int gridRes) {\" << std::endl;\n    ss << \"    Rcpp::List covsL = res[\\\"covariances\\\"];\" << std::endl;\n    ss << \"    Rcpp::List mL = res[\\\"means\\\"];\" << std::endl;\n    ss << \"    Rcpp::List dirsL = res[\\\"directions\\\"];\" << std::endl;\n    ss << \"    Rcpp::List coeffsL = res[\\\"coefficients\\\"];\" << std::endl;\n    ss << \"    int maxClusters = covsL.length();\" << std::endl;\n    ss << \"    Rcpp::List ellipsoidsL(maxClusters);\" << std::endl;\n    ss << \"    Rcpp::List ellipsoidsNL(maxClusters);\" << std::endl;\n    ss << \"    Rcpp::List ellipsoidsML(maxClusters);\" << std::endl;\n    ss << \"    Rcpp::List ellipsoidsMNL(maxClusters);\" << std::endl;\n    ss << \"    for (int i = 0; i < maxClusters; ++i) {\" << std::endl;\n    ss << \"        if (covsL[i] != R_NilValue) {\" << std::endl;\n    ss << \"            vec eigval;\" << std::endl;\n    ss << \"            mat eigvec;\" << std::endl;\n    ss << \"            mat cov = covsL[i];\" << std::endl;\n    ss << \"            eig_sym(eigval, eigvec, cov);\" << std::endl;\n    ss << \"            double percentile = R::qchisq(confidence, 3, 1, 0);\" << std::endl;\n    ss << \"            vec eAxes(3);\" << std::endl;\n    ss << \"            for (int j = 0; j < 3; ++j) eAxes(j) = sqrt(eigval(j) * percentile);\" << std::endl;\n    ss << \"            vec m = mL[i];\" << std::endl;\n    ss << \"            int dir = dirsL[i];\" << std::endl;\n    ss << \"            vec coeffs = coeffsL[i];\" << std::endl;\n    ss << std::endl;\n    ss << \"            mat verts(2 + ((gridRes - 1) * gridRes), 3);\" << std::endl;\n    ss << \"            verts(0, 0) = 0.0; verts(0, 1) = 0.0; verts(0, 2) = eAxes(2);\" << std::endl;\n    ss << \"            for (int j = 1; j < gridRes; ++j) {\" << std::endl;\n    ss << \"                for (int k = 0; k < gridRes; ++k) {\" << std::endl;\n    ss << \"                    verts(1 + ((j - 1) * gridRes) + k, 0) = eAxes(0) * sin((M_PI / gridRes) * j) * cos(((2 * M_PI) / gridRes) * k);\" << std::endl;\n    ss << \"                    verts(1 + ((j - 1) * gridRes) + k, 1) = eAxes(1) * sin((M_PI / gridRes) * j) * sin(((2 * M_PI) / gridRes) * k);\" << std::endl;\n    ss << \"                    verts(1 + ((j - 1) * gridRes) + k, 2) = eAxes(2) * cos((M_PI / gridRes) * j);\" << std::endl;\n    ss << \"                }\" << std::endl;\n    ss << \"            }\" << std::endl;\n    ss << \"            verts(1 + ((gridRes - 1) * gridRes), 0) = 0.0;\" << std::endl;\n    ss << \"            verts(1 + ((gridRes - 1) * gridRes), 1) = 0.0;\" << std::endl;\n    ss << \"            verts(1 + ((gridRes - 1) * gridRes), 2) = -eAxes(2);\" << std::endl;\n    ss << std::endl;\n    ss << \"            verts = (eigvec * verts.t()).t();\" << std::endl;\n    ss << \"            for (int j = 0; j < verts.n_rows; ++j) {\" << std::endl;\n    ss << \"                vec tmp = verts.row(j).t();\" << std::endl;\n    ss << \"                for (int k = 0; k < tmp.n_elem; ++k) {\" << std::endl;\n    ss << \"                    if (k != dir) tmp(k) += m(k);\" << std::endl;\n    ss << \"                }\" << std::endl;\n    ss << \"                verts.row(j) = tmp.t();\" << std::endl;\n    ss << \"                tmp.shed_row(dir);\" << std::endl;\n    ss << \"                vec values = f(tmp);\" << std::endl;\n    ss << \"                double value = 0.0;\" << std::endl;\n    ss << \"                for (int k = 0; k < coeffs.n_elem; ++k) value += coeffs(k) * values(k);\" << std::endl;\n    ss << \"                verts(j, dir) += value;\" << std::endl;\n    ss << \"            }\" << std::endl;\n    ss << std::endl;\n    ss << \"            umat faces((gridRes * 2) + (((gridRes - 2) * gridRes) * 2), 3);\" << std::endl;\n    ss << \"            for (int j = 0; j < gridRes; ++j) {\" << std::endl;\n    ss << \"                faces(j, 0) = 0;\" << std::endl;\n    ss << \"                faces(j, 1) = 1 + ((j + 1) % gridRes);\" << std::endl;\n    ss << \"                faces(j, 2) = 1 + j;\" << std::endl;\n    ss << \"            }\" << std::endl;\n    ss << \"            for (int j = 0; j < gridRes - 2; ++j) {\" << std::endl;\n    ss << \"                for (int k = 0; k < gridRes; ++k) {\" << std::endl;\n    ss << \"                    faces(gridRes + (((j * gridRes) + k) * 2), 0) = 1 + (j * gridRes) + k;\" << std::endl;\n    ss << \"                    faces(gridRes + (((j * gridRes) + k) * 2), 1) = 1 + (j * gridRes) + ((k + 1) % gridRes);\" << std::endl;\n    ss << \"                    faces(gridRes + (((j * gridRes) + k) * 2), 2) = 1 + ((j + 1) * gridRes) + ((k + 1) % gridRes);\" << std::endl;\n    ss << \"                    faces(gridRes + (((j * gridRes) + k) * 2) + 1, 0) = 1 + (j * gridRes) + k;\" << std::endl;\n    ss << \"                    faces(gridRes + (((j * gridRes) + k) * 2) + 1, 1) = 1 + ((j + 1) * gridRes) + ((k + 1) % gridRes);\" << std::endl;\n    ss << \"                    faces(gridRes + (((j * gridRes) + k) * 2) + 1, 2) = 1 + ((j + 1) * gridRes) + k;\" << std::endl;\n    ss << \"                }\" << std::endl;\n    ss << \"            }\" << std::endl;\n    ss << \"            for (int j = 0; j < gridRes; ++j) {\" << std::endl;\n    ss << \"                faces(gridRes + (((gridRes - 2) * gridRes) * 2) + j, 0) = 1 + ((gridRes - 2) * gridRes) + j;\" << std::endl;\n    ss << \"                faces(gridRes + (((gridRes - 2) * gridRes) * 2) + j, 1) = 1 + ((gridRes - 2) * gridRes) + ((j + 1) % gridRes);\" << std::endl;\n    ss << \"                faces(gridRes + (((gridRes - 2) * gridRes) * 2) + j, 2) = 1 + ((gridRes - 1) * gridRes);\" << std::endl;\n    ss << \"            }\" << std::endl;\n    ss << std::endl;\n    ss << \"            mat fNormals(faces.n_rows, 3);\" << std::endl;\n    ss << \"            for (int j = 0; j < faces.n_rows; ++j) {\" << std::endl;\n    ss << \"                unsigned i1 = faces(j, 0);\" << std::endl;\n    ss << \"                unsigned i2 = faces(j, 1);\" << std::endl;\n    ss << \"                unsigned i3 = faces(j, 2);\" << std::endl;\n    ss << \"                vec v1 = verts.row(i1).t();\" << std::endl;\n    ss << \"                vec v2 = verts.row(i2).t();\" << std::endl;\n    ss << \"                vec v3 = verts.row(i3).t();\" << std::endl;\n    ss << \"                vec N = normalise(cross(v2 - v1, v3 - v1));\" << std::endl;\n    ss << \"                fNormals.row(j) = N.t();\" << std::endl;\n    ss << \"            }\" << std::endl;\n    ss << std::endl;\n    ss << \"            mat vNormals(verts.n_rows, 3, fill::zeros);\" << std::endl;\n    ss << \"            for (int j = 0; j < faces.n_rows; ++j) {\" << std::endl;\n    ss << \"                unsigned i1 = faces(j, 0);\" << std::endl;\n    ss << \"                unsigned i2 = faces(j, 1);\" << std::endl;\n    ss << \"                unsigned i3 = faces(j, 2);\" << std::endl;\n    ss << \"                vNormals.row(i1) += fNormals.row(j);\" << std::endl;\n    ss << \"                vNormals.row(i2) += fNormals.row(j);\" << std::endl;\n    ss << \"                vNormals.row(i3) += fNormals.row(j);\" << std::endl;\n    ss << \"            }\" << std::endl;\n    ss << std::endl;\n    ss << \"            for (int j = 0; j < vNormals.n_rows; ++j) vNormals.row(j) = normalise(vNormals.row(j));\" << std::endl;\n    ss << std::endl;\n    ss << \"            mat eFaces(faces.n_rows * 3, 3);\" << std::endl;\n    ss << \"            mat eNormals(faces.n_rows * 3, 3);\" << std::endl;\n    ss << \"            for (int j = 0; j < faces.n_rows; ++j) {\" << std::endl;\n    ss << \"                unsigned i1 = faces(j, 0);\" << std::endl;\n    ss << \"                unsigned i2 = faces(j, 1);\" << std::endl;\n    ss << \"                unsigned i3 = faces(j, 2);\" << std::endl;\n    ss << \"                eFaces.row(j * 3) = verts.row(i1);\" << std::endl;\n    ss << \"                eFaces.row((j * 3) + 1) = verts.row(i2);\" << std::endl;\n    ss << \"                eFaces.row((j * 3) + 2) = verts.row(i3);\" << std::endl;\n    ss << \"                eNormals.row(j * 3) = vNormals.row(i1);\" << std::endl;\n    ss << \"                eNormals.row((j * 3) + 1) = vNormals.row(i2);\" << std::endl;\n    ss << \"                eNormals.row((j * 3) + 2) = vNormals.row(i3);\" << std::endl;\n    ss << \"            }\" << std::endl;\n    ss << std::endl;\n    ss << \"            ellipsoidsL[i] = eFaces;\" << std::endl;\n    ss << \"            ellipsoidsNL[i] = eNormals;\" << std::endl;\n    ss << std::endl;\n    ss << \"            cov.shed_row(dir);\" << std::endl;\n    ss << \"            cov.shed_col(dir);\" << std::endl;\n    ss << \"            eig_sym(eigval, eigvec, cov);\" << std::endl;\n    ss << \"            for (int j = 0; j < 2; ++j) eAxes(j) = sqrt(eigval(j) * percentile);\" << std::endl;\n    ss << std::endl;\n    ss << \"            mat vertsM(1 + (gridRes * gridRes), 2);\" << std::endl;\n    ss << \"            verts(0, 0) = 0.0; verts(0, 1) = 0.0;\" << std::endl;\n    ss << \"            for (int j = 1; j <= gridRes; ++j) {\" << std::endl;\n    ss << \"                for (int k = 0; k < gridRes; ++k) {\" << std::endl;\n    ss << \"                    vertsM(1 + ((j - 1) * gridRes) + k, 0) = ((eAxes(0) / gridRes) * j) * cos(((2 * M_PI) / gridRes) * k);\" << std::endl;\n    ss << \"                    vertsM(1 + ((j - 1) * gridRes) + k, 1) = ((eAxes(1) / gridRes) * j) * sin(((2 * M_PI) / gridRes) * k);\" << std::endl;\n    ss << \"                }\" << std::endl;\n    ss << \"            }\" << std::endl;\n    ss << std::endl;\n    ss << \"            vertsM = (eigvec * vertsM.t()).t();\" << std::endl;\n    ss << \"            vertsM.insert_cols(dir, 1, true);\" << std::endl;\n    ss << \"            for (int j = 0; j < vertsM.n_rows; ++j) {\" << std::endl;\n    ss << \"                vec tmp = vertsM.row(j).t();\" << std::endl;\n    ss << \"                for (int k = 0; k < tmp.n_elem; ++k) {\" << std::endl;\n    ss << \"                    if (k != dir) tmp(k) += m(k);\" << std::endl;\n    ss << \"                }\" << std::endl;\n    ss << \"                vertsM.row(j) = tmp.t();\" << std::endl;\n    ss << \"                tmp.shed_row(dir);\" << std::endl;\n    ss << \"                vec values = f(tmp);\" << std::endl;\n    ss << \"                double value = 0.0;\" << std::endl;\n    ss << \"                for (int k = 0; k < coeffs.n_elem; ++k) value += coeffs(k) * values(k);\" << std::endl;\n    ss << \"                vertsM(j, dir) += value;\" << std::endl;\n    ss << \"            }\" << std::endl;\n    ss << std::endl;\n    ss << \"            umat facesM(gridRes + (((gridRes - 1) * gridRes) * 2), 3);\" << std::endl;\n    ss << \"            for (int j = 0; j < gridRes; ++j) {\" << std::endl;\n    ss << \"                facesM(j, 0) = 0;\" << std::endl;\n    ss << \"                facesM(j, 1) = 1 + ((j + 1) % gridRes);\" << std::endl;\n    ss << \"                facesM(j, 2) = 1 + j;\" << std::endl;\n    ss << \"            }\" << std::endl;\n    ss << \"            for (int j = 0; j < gridRes - 1; ++j) {\" << std::endl;\n    ss << \"                for (int k = 0; k < gridRes; ++k) {\" << std::endl;\n    ss << \"                    facesM(gridRes + (((j * gridRes) + k) * 2), 0) = 1 + (j * gridRes) + k;\" << std::endl;\n    ss << \"                    facesM(gridRes + (((j * gridRes) + k) * 2), 1) = 1 + (j * gridRes) + ((k + 1) % gridRes);\" << std::endl;\n    ss << \"                    facesM(gridRes + (((j * gridRes) + k) * 2), 2) = 1 + ((j + 1) * gridRes) + ((k + 1) % gridRes);\" << std::endl;\n    ss << \"                    facesM(gridRes + (((j * gridRes) + k) * 2) + 1, 0) = 1 + (j * gridRes) + k;\" << std::endl;\n    ss << \"                    facesM(gridRes + (((j * gridRes) + k) * 2) + 1, 1) = 1 + ((j + 1) * gridRes) + ((k + 1) % gridRes);\" << std::endl;\n    ss << \"                    facesM(gridRes + (((j * gridRes) + k) * 2) + 1, 2) = 1 + ((j + 1) * gridRes) + k;\" << std::endl;\n    ss << \"                }\" << std::endl;\n    ss << \"            }\" << std::endl;\n    ss << std::endl;\n    ss << \"            mat fNormalsM(facesM.n_rows, 3);\" << std::endl;\n    ss << \"            for (int j = 0; j < facesM.n_rows; ++j) {\" << std::endl;\n    ss << \"                unsigned i1 = facesM(j, 0);\" << std::endl;\n    ss << \"                unsigned i2 = facesM(j, 1);\" << std::endl;\n    ss << \"                unsigned i3 = facesM(j, 2);\" << std::endl;\n    ss << \"                vec v1 = vertsM.row(i1).t();\" << std::endl;\n    ss << \"                vec v2 = vertsM.row(i2).t();\" << std::endl;\n    ss << \"                vec v3 = vertsM.row(i3).t();\" << std::endl;\n    ss << \"                vec N = normalise(cross(v2 - v1, v3 - v1));\" << std::endl;\n    ss << \"                fNormalsM.row(j) = N.t();\" << std::endl;\n    ss << \"            }\" << std::endl;\n    ss << std::endl;\n    ss << \"            mat vNormalsM(vertsM.n_rows, 3, fill::zeros);\" << std::endl;\n    ss << \"            for (int j = 0; j < facesM.n_rows; ++j) {\" << std::endl;\n    ss << \"                unsigned i1 = facesM(j, 0);\" << std::endl;\n    ss << \"                unsigned i2 = facesM(j, 1);\" << std::endl;\n    ss << \"                unsigned i3 = facesM(j, 2);\" << std::endl;\n    ss << \"                vNormalsM.row(i1) += fNormalsM.row(j);\" << std::endl;\n    ss << \"                vNormalsM.row(i2) += fNormalsM.row(j);\" << std::endl;\n    ss << \"                vNormalsM.row(i3) += fNormalsM.row(j);\" << std::endl;\n    ss << \"            }\" << std::endl;\n    ss << std::endl;\n    ss << \"            for (int j = 0; j < vNormalsM.n_rows; ++j) vNormalsM.row(j) = normalise(vNormalsM.row(j));\" << std::endl;\n    ss << std::endl;\n    ss << \"            mat eMFaces(facesM.n_rows * 3, 3);\" << std::endl;\n    ss << \"            mat eMNormals(facesM.n_rows * 3, 3);\" << std::endl;\n    ss << \"            for (int j = 0; j < facesM.n_rows; ++j) {\" << std::endl;\n    ss << \"                unsigned i1 = facesM(j, 0);\" << std::endl;\n    ss << \"                unsigned i2 = facesM(j, 1);\" << std::endl;\n    ss << \"                unsigned i3 = facesM(j, 2);\" << std::endl;\n    ss << \"                eMFaces.row(j * 3) = vertsM.row(i1);\" << std::endl;\n    ss << \"                eMFaces.row((j * 3) + 1) = vertsM.row(i2);\" << std::endl;\n    ss << \"                eMFaces.row((j * 3) + 2) = vertsM.row(i3);\" << std::endl;\n    ss << \"                eMNormals.row(j * 3) = vNormalsM.row(i1);\" << std::endl;\n    ss << \"                eMNormals.row((j * 3) + 1) = vNormalsM.row(i2);\" << std::endl;\n    ss << \"                eMNormals.row((j * 3) + 2) = vNormalsM.row(i3);\" << std::endl;\n    ss << \"            }\" << std::endl;\n    ss << std::endl;\n    ss << \"            ellipsoidsML[i] = eMFaces;\" << std::endl;\n    ss << \"            ellipsoidsMNL[i] = eMNormals;\" << std::endl;\n    ss << \"        } else {\" << std::endl;\n    ss << \"            ellipsoidsL[i] = R_NilValue;\" << std::endl;\n    ss << \"            ellipsoidsNL[i] = R_NilValue;\" << std::endl;\n    ss << \"            ellipsoidsML[i] = R_NilValue;\" << std::endl;\n    ss << \"            ellipsoidsMNL[i] = R_NilValue;\" << std::endl;\n    ss << \"        }\" << std::endl;\n    ss << \"    }\" << std::endl;\n    ss << \"    return Rcpp::List::create(ellipsoidsL, ellipsoidsNL, ellipsoidsML, ellipsoidsMNL);\" << std::endl;\n    ss << \"}\" << std::endl;\n\n    return ss.str();\n}\n\n//   -*-   -*-   -*-\n\nSEXP afCECLloyd(\n    const mat &points,\n    int maxClusters,\n    ivec labels,\n    double cardMin,\n    int minIterations,\n    int maxIterations,\n    const mat &values,\n    bool interactive\n) {\n    int *card = NULL;\n    vec **m = NULL;\n    mat **sigma = NULL;\n    mat ***A = NULL;\n    vec ***b = NULL;\n    double **sumOfSquares = NULL;\n    double *E = NULL;\n    int *bestAxes = NULL;\n    vec **coeffs = NULL;\n    double *probabilities = NULL;\n\n    int pointsNum = points.n_cols;\n    int dim = points.n_rows;\n    int dimA = values.n_rows / dim;\n\n    Rcpp::List res;\n\n    card = new int[maxClusters];\n    std::set<int> activeClusters;\n    std::set<int> inactiveClusters;\n    for (int i = 0; i < maxClusters; ++i) card[i] = 0;\n    for (int i = 0; i < pointsNum; ++i) ++card[labels[i]];\n    for (int i = 0; i < maxClusters; ++i) {\n        if ((card[i] >= dim + 1) && (((double)card[i]) / pointsNum >= cardMin)) activeClusters.insert(activeClusters.end(), i);\n        else {\n            if (card[i] > 0) inactiveClusters.insert(inactiveClusters.end(), i);\n        }\n    }\n\n    m = new vec*[maxClusters];\n    sigma = new mat*[maxClusters];\n    A = new mat**[maxClusters];\n    b = new vec**[maxClusters];\n    sumOfSquares = new double*[maxClusters];\n    E = new double[maxClusters];\n    bestAxes = new int[maxClusters];\n    coeffs = new vec*[maxClusters];\n    probabilities = new double[maxClusters];\n    for (int i = 0; i < maxClusters; ++i) {\n        m[i] = NULL;\n        sigma[i] = NULL;\n        A[i] = NULL;\n        b[i] = NULL;\n        sumOfSquares[i] = NULL;\n        coeffs[i] = NULL;\n    }\n    for (std::set<int>::iterator it = activeClusters.begin(); it != activeClusters.end(); ++it) {\n        m[*it] = new vec(dim, fill::zeros);\n        sigma[*it] = new mat(dim, dim, fill::zeros);\n        A[*it] = new mat*[dim];\n        b[*it] = new vec*[dim];\n        sumOfSquares[*it] = new double[dim];\n        E[*it] = 0.0;\n        coeffs[*it] = new vec(dimA, fill::zeros);\n        for (int i = 0; i < dim; ++i) {\n            A[*it][i] = NULL;\n            b[*it][i] = NULL;\n        }\n        for (int i = 0; i < dim; ++i) {\n            A[*it][i] = new mat(dimA, dimA, fill::zeros);\n            b[*it][i] = new vec(dimA, fill::zeros);\n            sumOfSquares[*it][i] = 0.0;\n        }\n    }\n\n    for (int i = 0; i < pointsNum; ++i) {\n        int cl = labels[i];\n        if (activeClusters.find(cl) != activeClusters.end()) {\n            vec p = points.col(i);\n            *m[cl] += p;\n            for (int j = 0; j < dim; ++j) {\n                vec v = values.submat(j * dimA, i, size(dimA, 1)); // Zamienic na liste!\n                *A[cl][j] += v * v.t();\n                *b[cl][j] += p[j] * v;\n                sumOfSquares[cl][j] += p[j] * p[j];\n            }\n        }\n    }\n    for (std::set<int>::iterator it = activeClusters.begin(); it != activeClusters.end(); ++it) {\n        *m[*it] /= card[*it];\n        probabilities[*it] = ((double)card[*it]) / pointsNum;\n    }\n\n    for (int i = 0; i < pointsNum; ++i) {\n        int cl = labels[i];\n        if (activeClusters.find(cl) != activeClusters.end())\n            *sigma[cl] += (points.col(i) - *m[cl]) * (points.col(i) - *m[cl]).t();\n    }\n    for (std::set<int>::iterator it = activeClusters.begin(); it != activeClusters.end();) {\n        *sigma[*it] /= card[*it];\n        double EMin = INFINITY;\n        int bestAxis;\n        double bestVar;\n        vec bestCoeff;\n        try {\n            for (int i = 0; i < dim; ++i) {\n                vec x = solve(*A[*it][i], *b[*it][i]);\n                double var = sumOfSquares[*it][i];\n                var -= ((vec)(2.0 * x.t() * *b[*it][i]))[0];\n                var += ((mat)(x.t() * *A[*it][i] * x)).at(0, 0);\n                var /= card[*it];\n\n                mat sigmaTmp = *sigma[*it];\n                sigmaTmp(i, span::all).fill(0.0);\n                sigmaTmp(span::all, i).fill(0.0);\n                sigmaTmp(i, i) = var;\n\n                double prob = probabilities[*it];\n                double ETmp = prob * (-log(prob) + (0.5 * ((dim * log(2.0 * M_PI * M_E)) + log(det(sigmaTmp)))));\n                if (!is_finite(ETmp)) throw 0;\n                if (ETmp < EMin) {\n                    EMin = ETmp;\n                    bestAxis = i;\n                    bestVar = var;\n                    bestCoeff = x;\n                }\n            }\n            E[*it] = EMin;\n            (*sigma[*it])(bestAxis, span::all).fill(0.0);\n            (*sigma[*it])(span::all, bestAxis).fill(0.0);\n            (*sigma[*it])(bestAxis, bestAxis) = bestVar;\n            bestAxes[*it] = bestAxis;\n            *coeffs[*it] = bestCoeff;\n            ++it;\n        } catch (...) {\n            std::set<int>::iterator itTmp = it;\n            ++itTmp;\n            inactiveClusters.insert(*it);\n            activeClusters.erase(it);\n            it = itTmp;\n        }\n    }\n\n    //   -*-   -*-   -*-\n\n    for (std::set<int>::iterator it1 = inactiveClusters.begin(); it1 != inactiveClusters.end(); ++it1) {\n        printf(\"WYWALANIE Z KLASTRA: %d\\n\", *it1); // !!!\n\n        for (int i = 0; i < pointsNum; ++i) {\n            int cl = labels[i];\n            if (*it1 == cl) {\n                int bestCl;\n                double EMin = INFINITY;\n                for (std::set<int>::iterator it2 = activeClusters.begin(); it2 != activeClusters.end(); ++it2) {\n                    for (int j = 0; j < dim; ++j) {\n                        vec p = points.col(i) - *m[*it2];\n                        p[bestAxes[*it2]] = points.col(i)(bestAxes[*it2]) - ((mat)(coeffs[*it2]->t() * values.submat(bestAxes[*it2] * dimA, i, size(dimA, 1))))(0, 0);\n                        double prob = probabilities[*it2];\n                        double ETmp = -log(prob) + (0.5 * ((dim * log(2.0 * M_PI)) + log(det(*sigma[*it2])) + ((mat)(p.t() * inv(*sigma[*it2]) * p))(0, 0)));\n                        if (!is_finite(ETmp)) throw 0;\n                        if (ETmp < EMin) {\n                            EMin = ETmp;\n                            bestCl = *it2;\n                        }\n                    }\n                }\n                labels[i] = bestCl;\n                ++card[labels[i]];\n            }\n        }\n    }\n    inactiveClusters.clear();\n\n    for (std::set<int>::iterator it = activeClusters.begin(); it != activeClusters.end(); ++it) {\n        m[*it]->fill(0.0);\n        sigma[*it]->fill(0.0);\n        for (int i = 0; i < dim; ++i) {\n            A[*it][i]->fill(0.0);\n            b[*it][i]->fill(0.0);\n            sumOfSquares[*it][i] = 0.0;\n        }\n    }\n\n    for (int i = 0; i < maxClusters; ++i) card[i] = 0;\n    for (int i = 0; i < pointsNum; ++i) ++card[labels[i]];\n\n    for (int i = 0; i < pointsNum; ++i) {\n        int cl = labels[i];\n        if (activeClusters.find(cl) != activeClusters.end()) {\n            vec p = points.col(i);\n            *m[cl] += p;\n            for (int j = 0; j < dim; ++j) {\n                vec v = values.submat(j * dimA, i, size(dimA, 1)); // Zamienic na liste!\n                *A[cl][j] += v * v.t();\n                *b[cl][j] += p[j] * v;\n                sumOfSquares[cl][j] += p[j] * p[j];\n            }\n        }\n    }\n    for (std::set<int>::iterator it = activeClusters.begin(); it != activeClusters.end(); ++it) {\n        *m[*it] /= card[*it];\n        probabilities[*it] = ((double)card[*it]) / pointsNum;\n    }\n\n    for (int i = 0; i < pointsNum; ++i) {\n        int cl = labels[i];\n        if (activeClusters.find(cl) != activeClusters.end())\n            *sigma[cl] += (points.col(i) - *m[cl]) * (points.col(i) - *m[cl]).t();\n    }\n    for (std::set<int>::iterator it = activeClusters.begin(); it != activeClusters.end();) {\n        *sigma[*it] /= card[*it];\n        double EMin = INFINITY;\n        int bestAxis;\n        double bestVar;\n        vec bestCoeff;\n\n        for (int i = 0; i < dim; ++i) {\n            vec x = solve(*A[*it][i], *b[*it][i]);\n            double var = sumOfSquares[*it][i];\n            var -= ((vec)(2.0 * x.t() * *b[*it][i]))[0];\n            var += ((mat)(x.t() * *A[*it][i] * x)).at(0, 0);\n            var /= card[*it];\n\n            mat sigmaTmp = *sigma[*it];\n            sigmaTmp(i, span::all).fill(0.0);\n            sigmaTmp(span::all, i).fill(0.0);\n            sigmaTmp(i, i) = var;\n\n            double prob = probabilities[*it];\n            double ETmp = prob * (-log(prob) + (0.5 * ((dim * log(2.0 * M_PI * M_E)) + log(det(sigmaTmp)))));\n            if (!is_finite(ETmp)) throw 0;\n            if (ETmp < EMin) {\n                EMin = ETmp;\n                bestAxis = i;\n                bestVar = var;\n                bestCoeff = x;\n            }\n        }\n        E[*it] = EMin;\n        (*sigma[*it])(bestAxis, span::all).fill(0.0);\n        (*sigma[*it])(span::all, bestAxis).fill(0.0);\n        (*sigma[*it])(bestAxis, bestAxis) = bestVar;\n        bestAxes[*it] = bestAxis;\n        *coeffs[*it] = bestCoeff;\n        ++it;\n    }\n\n    //   -*-   -*-   -*-\n\n    double ETotalOld;\n    double ETotalNew = 0.0;\n    for (std::set<int>::iterator it = activeClusters.begin(); it != activeClusters.end(); ++it) ETotalNew += E[*it];\n    double dETotalThreshold = 0.0;//0.0001; // !!!\n    int numberOfIterations = 0;\n    do {\n        ETotalOld = ETotalNew;\n\n        for (int i = 0; i < pointsNum; ++i) {\n            int bestCl;\n            double EMin = INFINITY;\n            for (std::set<int>::iterator it = activeClusters.begin(); it != activeClusters.end(); ++it) {\n                vec p = points.col(i) - *m[*it];\n                p[bestAxes[*it]] = points.col(i)(bestAxes[*it]) - ((mat)(coeffs[*it]->t() * values.submat(bestAxes[*it] * dimA, i, size(dimA, 1))))(0, 0);\n                double prob = probabilities[*it];\n                double ETmp = -log(prob) + (0.5 * ((dim * log(2.0 * M_PI)) + log(det(*sigma[*it])) + ((mat)(p.t() * inv(*sigma[*it]) * p))(0, 0)));\n                if (!is_finite(ETmp)) throw 0;\n                if (ETmp < EMin) {\n                    EMin = ETmp;\n                    bestCl = *it;\n                }\n            }\n            labels[i] = bestCl;\n        }\n\n        activeClusters.clear();\n        inactiveClusters.clear();\n        for (int i = 0; i < maxClusters; ++i) card[i] = 0;\n        for (int i = 0; i < pointsNum; ++i) ++card[labels[i]];\n        for (int i = 0; i < maxClusters; ++i) {\n            if ((card[i] >= dim + 1) && (((double)card[i]) / pointsNum >= cardMin)) activeClusters.insert(activeClusters.end(), i);\n            else {\n                if (card[i] > 0) inactiveClusters.insert(inactiveClusters.end(), i);\n            }\n        }\n\n        // !!! REMOVAL !!!\n        for (std::set<int>::iterator it1 = inactiveClusters.begin(); it1 != inactiveClusters.end(); ++it1) {\n            printf(\"WYWALANIE Z KLASTRA: %d\\n\", *it1); // !!!\n\n            for (int i = 0; i < pointsNum; ++i) {\n                int cl = labels[i];\n                if (*it1 == cl) {\n                    int bestCl;\n                    double EMin = INFINITY;\n                    for (std::set<int>::iterator it2 = activeClusters.begin(); it2 != activeClusters.end(); ++it2) {\n                        for (int j = 0; j < dim; ++j) {\n                            vec p = points.col(i) - *m[*it2];\n                            p[bestAxes[*it2]] = points.col(i)(bestAxes[*it2]) - ((mat)(coeffs[*it2]->t() * values.submat(bestAxes[*it2] * dimA, i, size(dimA, 1))))(0, 0);\n                            double prob = probabilities[*it2];\n                            double ETmp = -log(prob) + (0.5 * ((dim * log(2.0 * M_PI)) + log(det(*sigma[*it2])) + ((mat)(p.t() * inv(*sigma[*it2]) * p))(0, 0)));\n                            if (!is_finite(ETmp)) throw 0;\n                            if (ETmp < EMin) {\n                                EMin = ETmp;\n                                bestCl = *it2;\n                            }\n                        }\n                    }\n                    labels[i] = bestCl;\n                    ++card[labels[i]];\n                }\n            }\n            card[*it1] = 0;\n        }\n        inactiveClusters.clear();\n        // !!! REMOVAL !!!\n\n        // !!!\n        for (std::set<int>::iterator it = activeClusters.begin(); it != activeClusters.end(); ++it) {\n            m[*it]->fill(0.0);\n            sigma[*it]->fill(0.0);\n            for (int i = 0; i < dim; ++i) {\n                A[*it][i]->fill(0.0);\n                b[*it][i]->fill(0.0);\n                sumOfSquares[*it][i] = 0.0;\n            }\n        }\n        // !!!\n\n        for (int i = 0; i < pointsNum; ++i) {\n            int cl = labels[i];\n            if (activeClusters.find(cl) != activeClusters.end()) {\n                vec p = points.col(i);\n                *m[cl] += p;\n                for (int j = 0; j < dim; ++j) {\n                    vec v = values.submat(j * dimA, i, size(dimA, 1)); // Zamienic na liste!\n                    *A[cl][j] += v * v.t();\n                    *b[cl][j] += p[j] * v;\n                    sumOfSquares[cl][j] += p[j] * p[j];\n                }\n            }\n        }\n        for (std::set<int>::iterator it = activeClusters.begin(); it != activeClusters.end(); ++it) {\n            *m[*it] /= card[*it];\n            probabilities[*it] = ((double)card[*it]) / pointsNum;\n        }\n\n        for (int i = 0; i < pointsNum; ++i) {\n            int cl = labels[i];\n            if (activeClusters.find(cl) != activeClusters.end())\n                *sigma[cl] += (points.col(i) - *m[cl]) * (points.col(i) - *m[cl]).t();\n        }\n        for (std::set<int>::iterator it = activeClusters.begin(); it != activeClusters.end();) {\n            *sigma[*it] /= card[*it];\n            double EMin = INFINITY;\n            int bestAxis;\n            double bestVar;\n            vec bestCoeff;\n            try {\n                for (int i = 0; i < dim; ++i) {\n                    vec x = solve(*A[*it][i], *b[*it][i]);\n                    double var = sumOfSquares[*it][i];\n                    var -= ((vec)(2.0 * x.t() * *b[*it][i]))[0];\n                    var += ((mat)(x.t() * *A[*it][i] * x)).at(0, 0);\n                    var /= card[*it];\n\n                    mat sigmaTmp = *sigma[*it];\n                    sigmaTmp(i, span::all).fill(0.0);\n                    sigmaTmp(span::all, i).fill(0.0);\n                    sigmaTmp(i, i) = var;\n\n                    double prob = ((double)card[*it]) / pointsNum;\n                    double ETmp = prob * (-log(prob) + (0.5 * ((dim * log(2.0 * M_PI * M_E)) + log(det(sigmaTmp)))));\n                    if (!is_finite(ETmp)) throw 0;\n                    if (ETmp < EMin) {\n                        EMin = ETmp;\n                        bestAxis = i;\n                        bestVar = var;\n                        bestCoeff = x;\n                    }\n                }\n                E[*it] = EMin;\n                (*sigma[*it])(bestAxis, span::all).fill(0.0);\n                (*sigma[*it])(span::all, bestAxis).fill(0.0);\n                (*sigma[*it])(bestAxis, bestAxis) = bestVar;\n                bestAxes[*it] = bestAxis;\n                *coeffs[*it] = bestCoeff;\n                ++it;\n            } catch (...) {\n                std::set<int>::iterator itTmp = it;\n                ++itTmp;\n                inactiveClusters.insert(*it);\n                activeClusters.erase(it);\n                it = itTmp;\n            }\n        }\n\n        ETotalNew = 0.0;\n        for (std::set<int>::iterator it = activeClusters.begin(); it != activeClusters.end(); ++it) ETotalNew += E[*it];\n        if (!is_finite(ETotalNew)) throw \"A numerical overflow occurred.\";\n\n        //printf(\"%d | %d: %.10lf\\n\", activeClusters.size(), numberOfIterations + 1, ETotalNew); // !!!\n\n        if (interactive) {\n            Rcpp::List cardL(maxClusters);\n            Rcpp::List mL(maxClusters);\n            Rcpp::List covL(maxClusters);\n            Rcpp::List coeffsL(maxClusters);\n            Rcpp::List dirsL(maxClusters);\n            for (int i = 0; i < maxClusters; ++i) {\n                if (activeClusters.find(i) != activeClusters.end()) {\n                    cardL[i] = card[i];\n                    mL[i] = *m[i];\n                    covL[i] = *sigma[i];\n                    coeffsL[i] = *coeffs[i];\n                    dirsL[i] = bestAxes[i];\n                } else {\n                    cardL[i] = 0;\n                    mL[i] = R_NilValue;\n                    covL[i] = R_NilValue;\n                    coeffsL[i] = R_NilValue;\n                    dirsL[i] = R_NilValue;\n                }\n            }\n            res.push_back(Rcpp::List::create(\n                Rcpp::Named(\"cardinalities\", cardL),\n                Rcpp::Named(\"number_of_clusters\", (int)activeClusters.size()),\n                Rcpp::Named(\"labels\", labels),\n                Rcpp::Named(\"means\", mL),\n                Rcpp::Named(\"covariances\", covL),\n                Rcpp::Named(\"coefficients\", coeffsL),\n                Rcpp::Named(\"directions\", dirsL),\n                Rcpp::Named(\"cost_total\", ETotalNew)\n            ));\n        }\n\n        ++numberOfIterations;\n    } while ((numberOfIterations < minIterations) || ((numberOfIterations < maxIterations) && (ETotalNew - ETotalOld < dETotalThreshold)));\n\n    if (numberOfIterations < 2) printf(\"YABADABADOO!\\n\"); // !!!\n\n    //   -*-   -*-   -*-\n\n    if (!interactive) {\n        Rcpp::List cardL(maxClusters);\n        Rcpp::List mL(maxClusters);\n        Rcpp::List covL(maxClusters);\n        Rcpp::List coeffsL(maxClusters);\n        Rcpp::List dirsL(maxClusters);\n        for (int i = 0; i < maxClusters; ++i) {\n            if (activeClusters.find(i) != activeClusters.end()) {\n                cardL[i] = card[i];\n                mL[i] = *m[i];\n                covL[i] = *sigma[i];\n                coeffsL[i] = *coeffs[i];\n                dirsL[i] = bestAxes[i];\n            } else {\n                cardL[i] = 0;\n                mL[i] = R_NilValue;\n                covL[i] = R_NilValue;\n                coeffsL[i] = R_NilValue;\n                dirsL[i] = R_NilValue;\n            }\n        }\n        res = Rcpp::List::create(\n            Rcpp::Named(\"cardinalities\", cardL),\n            Rcpp::Named(\"number_of_clusters\", (int)activeClusters.size()),\n            Rcpp::Named(\"labels\", labels),\n            Rcpp::Named(\"means\", mL),\n            Rcpp::Named(\"covariances\", covL),\n            Rcpp::Named(\"coefficients\", coeffsL),\n            Rcpp::Named(\"directions\", dirsL),\n            Rcpp::Named(\"cost_total\", ETotalNew)\n        );\n    }\n    return res;\n}\n\n//   -*-   -*-   -*-\n\nRcpp::List afCECHartigan (\n    const mat &points,\n    int maxClusters,\n    ivec labels,\n    double cardMin,\n    int minIterations,\n    int maxIterations,\n    const mat &values,\n    bool interactive\n) {\n    int *card = NULL;\n    vec **m = NULL;\n    mat **sigma = NULL;\n    mat ***sigmaL = NULL;\n    mat ***A = NULL;\n    mat ***AL = NULL;\n    vec ***b = NULL;\n    double **sumOfSquares = NULL;\n    double *E = NULL;\n    int *bestAxes = NULL;\n    vec **coeffs = NULL;\n    double *variances = NULL;\n\n    mat *badCl; // !!! !!! !!!\n    int varErr = 0; // !!! !!! !!!\n\n    int pointsNum = points.n_cols;\n    int dim = points.n_rows;\n    int dimA = values.n_rows / dim;\n\n    Rcpp::List res;\n\n    card = new int[maxClusters];\n    std::set<int> activeClusters;\n    std::set<int> inactiveClusters;\n    for (int i = 0; i < maxClusters; ++i) card[i] = 0;\n    for (int i = 0; i < pointsNum; ++i) ++card[labels[i]];\n    for (int i = 0; i < maxClusters; ++i) {\n        if ((card[i] >= dim + 1) && (((double)card[i]) / pointsNum >= cardMin)) activeClusters.insert(activeClusters.end(), i);\n        else {\n            if (card[i] > 0) inactiveClusters.insert(inactiveClusters.end(), i);\n        }\n    }\n\n    m = new vec*[maxClusters];\n    sigma = new mat*[maxClusters];\n    sigmaL = new mat**[maxClusters];\n    A = new mat**[maxClusters];\n    AL = new mat**[maxClusters];\n    b = new vec**[maxClusters];\n    sumOfSquares = new double*[maxClusters];\n    E = new double[maxClusters];\n    bestAxes = new int[maxClusters];\n    coeffs = new vec*[maxClusters];\n    variances = new double[maxClusters];\n    for (int i = 0; i < maxClusters; ++i) {\n        m[i] = NULL;\n        sigma[i] = NULL;\n        sigmaL[i] = NULL;\n        A[i] = NULL;\n        AL[i] = NULL;\n        b[i] = NULL;\n        sumOfSquares[i] = NULL;\n        coeffs[i] = NULL;\n        variances[i] = 0.0;\n    }\n    for (std::set<int>::iterator it = activeClusters.begin(); it != activeClusters.end(); ++it) {\n        m[*it] = new vec(dim, fill::zeros);\n        sigma[*it] = new mat(dim, dim, fill::zeros);\n        sigmaL[*it] = new mat*[dim];\n        A[*it] = new mat*[dim];\n        AL[*it] = new mat*[dim];\n        b[*it] = new vec*[dim];\n        sumOfSquares[*it] = new double[dim];\n        E[*it] = 0.0;\n        coeffs[*it] = new vec(dimA, fill::zeros);\n        for (int i = 0; i < dim; ++i) {\n            sigmaL[*it][i] = NULL;\n            A[*it][i] = NULL;\n            AL[*it][i] = NULL;\n            b[*it][i] = NULL;\n        }\n        for (int i = 0; i < dim; ++i) {\n            sigmaL[*it][i] = new mat(dim - 1, dim - 1);\n            A[*it][i] = new mat(dimA, dimA, fill::zeros);\n            AL[*it][i] = new mat(dimA, dimA);\n            b[*it][i] = new vec(dimA, fill::zeros);\n            sumOfSquares[*it][i] = 0.0;\n        }\n    }\n\n    for (int i = 0; i < pointsNum; ++i) {\n        int cl = labels[i];\n        if (activeClusters.find(cl) != activeClusters.end()) {\n            vec p = points.col(i);\n            *m[cl] += p;\n            for (int j = 0; j < dim; ++j) {\n                vec v = values.submat(j * dimA, i, size(dimA, 1)); // Zamienic na liste!\n                *A[cl][j] += v * v.t();\n                *b[cl][j] += p[j] * v;\n                sumOfSquares[cl][j] += p[j] * p[j];\n            }\n        }\n    }\n    for (std::set<int>::iterator it = activeClusters.begin(); it != activeClusters.end(); ++it) *m[*it] /= card[*it];\n\n    for (int i = 0; i < pointsNum; ++i) {\n        int cl = labels[i];\n        if (activeClusters.find(cl) != activeClusters.end())\n            *sigma[cl] += (points.col(i) - *m[cl]) * (points.col(i) - *m[cl]).t();\n    }\n    for (std::set<int>::iterator it = activeClusters.begin(); it != activeClusters.end();) {\n        *sigma[*it] /= card[*it];\n        uvec ind(dim - 1);\n        for (int i = 0; i < dim - 1; ++i) ind[i] = i + 1;\n        double EMin = INFINITY;\n        int bestAxis;\n        double bestVar;\n        vec bestCoeff;\n        try {\n            for (int i = 0; i < dim; ++i) {\n                *sigmaL[*it][i] = chol(sigma[*it]->submat(ind, ind), \"lower\");\n                double det = 1.0;\n                for (int j = 0; j < dim - 1; ++j) det *= sigmaL[*it][i]->at(j, j);\n\n                *AL[*it][i] = chol(*A[*it][i], \"lower\");\n                vec y = solve(trimatl(*AL[*it][i]), *b[*it][i]);\n                vec x = solve(trimatu(AL[*it][i]->t()), y);\n                double var = sumOfSquares[*it][i];\n                var -= ((vec)(2.0 * x.t() * *b[*it][i]))[0];\n                var += ((mat)(x.t() * *A[*it][i] * x)).at(0, 0);\n                var /= card[*it];\n\n                double prob = ((double)card[*it]) / pointsNum;\n                double ETmp = prob * (-log(prob) + (0.5 * ((dim * log(2.0 * M_PI * M_E)) + log(det * det * var))));\n                if (!is_finite(ETmp)) throw 0;\n                if (ETmp < EMin) {\n                    EMin = ETmp;\n                    bestAxis = i; // byo: *it;\n                    bestCoeff = x;\n                    bestVar = var;\n                }\n\n                if (i < dim - 1) ind[i] = i;\n            }\n            E[*it] = EMin;\n            bestAxes[*it] = bestAxis;\n            *coeffs[*it] = bestCoeff;\n            variances[*it] = bestVar;\n            ++it;\n        } catch (mat &m) {\n            printf(\"VERY BAD CLUSTER!\\n\");\n            throw m;\n        } catch (...) {\n            std::set<int>::iterator itTmp = it;\n            ++itTmp;\n            inactiveClusters.insert(*it);\n            activeClusters.erase(it);\n            it = itTmp;\n\n            printf(\"JADZIA!\\n\");\n        }\n    }\n\n    //   -*-   -*-   -*-\n\n    double ETotalOld;\n    double ETotalNew = 0.0; // !!! !!! !!!\n    for (std::set<int>::iterator it = activeClusters.begin(); it != activeClusters.end(); ++it) ETotalNew += E[*it];\n    //printf(\"%lf\\n\", ETotalNew); // !!!\n    double dETotalThreshold = 0.0;//0.0001; // !!!\n    int numberOfIterations = 0;\n    do {\n        ETotalOld = ETotalNew;\n        for (int i = 0; i < pointsNum; ++i) {\n            int cl = labels[i];\n            if (activeClusters.find(cl) != activeClusters.end()) {\n                double dEMinExcl = INFINITY;\n                int bestAxisExcl;\n                double EMinExcl;\n                vec bestCoeffsExcl;\n                double bestVarExcl;\n                try {\n                    vec v = (points.submat(1, i, size(dim - 1, 1)) - m[cl]->subvec(1, dim - 1)) / sqrt(card[cl] - 1);\n                    for (int j = 0; j < dim; ++j) {\n                        mat sigmaLTmp = *sigmaL[cl][j];\n                        vec vTmp = v;\n                        CholeskyRankOneDowndate(sigmaLTmp, vTmp);\n                        sigmaLTmp *= sqrt(card[cl] / (card[cl] - 1.0));\n                        double det = 1.0;\n                        for (int k = 0; k < dim - 1; ++k) det *= sigmaLTmp.at(k, k);\n\n                        mat ALTmp = *AL[cl][j];\n                        vec vA = values.submat(j * dimA, i, size(dimA, 1));\n                        vec vATmp = vA;\n                        CholeskyRankOneDowndate(ALTmp, vATmp);\n                        vec bTmp = *b[cl][j] - (points.at(j, i) * vA);\n                        vec y = solve(trimatl(ALTmp), bTmp);\n                        vec x = solve(trimatu(ALTmp.t()), y);\n                        mat ATmp = *A[cl][j] - (vA * vA.t());\n                        double var = sumOfSquares[cl][j] - (points.at(j, i) * points.at(j, i));\n                        var -= ((vec)(2.0 * x.t() * bTmp))[0];\n                        var += ((mat)(x.t() * ATmp * x)).at(0, 0);\n                        var /= (card[cl] - 1);\n\n                        double prob = (card[cl] - 1.0) / pointsNum;\n                        double EExcl = prob * (-log(prob) + (0.5 * ((dim * log(2.0 * M_PI * M_E)) + log(det * det * var))));\n                        if (!is_finite(EExcl)) throw 0;\n                        if (EExcl - E[cl] < dEMinExcl) {\n                            dEMinExcl = EExcl - E[cl];\n                            bestAxisExcl = j;\n                            EMinExcl = EExcl;\n                            bestCoeffsExcl = x;\n                            bestVarExcl = var;\n                        }\n\n                        if (j < dim - 1) v[j] = (points.at(j, i) - (*m[cl])[j]) / sqrt(card[cl] - 1);\n                    }\n                } catch (...) {\n                    activeClusters.erase(activeClusters.find(cl));\n                    inactiveClusters.insert(cl);\n                }\n                if (activeClusters.find(cl) != activeClusters.end()) {\n                    double dEMinIncl = INFINITY;\n                    int bestClIncl;\n                    int bestAxisIncl;\n                    double EMinIncl;\n                    vec bestCoeffsIncl;\n                    double bestVarIncl;\n                    for (std::set<int>::iterator it = activeClusters.begin(); it != activeClusters.end(); ++it) {\n                        if ((*it != cl) && (activeClusters.find(*it) != activeClusters.end())) {\n                            vec v = (points.submat(1, i, size(dim - 1, 1)) - m[*it]->subvec(1, dim - 1)) / sqrt(card[*it] + 1);\n                            for (int j = 0; j < dim; ++j) {\n                                mat sigmaLTmp = *sigmaL[*it][j];\n                                vec vTmp = v;\n                                CholeskyRankOneUpdate(sigmaLTmp, vTmp);\n                                sigmaLTmp *= sqrt(card[*it] / (card[*it] + 1.0));\n                                double det = 1.0;\n                                for (int k = 0; k < dim - 1; ++k) det *= sigmaLTmp.at(k, k);\n\n                                mat ALTmp = *AL[*it][j];\n                                vec vA = values.submat(j * dimA, i, size(dimA, 1));\n                                vec vATmp = vA;\n                                CholeskyRankOneUpdate(ALTmp, vATmp);\n                                vec bTmp = *b[*it][j] + (points.at(j, i) * vA);\n                                vec y = solve(trimatl(ALTmp), bTmp);\n                                vec x = solve(trimatu(ALTmp.t()), y);\n                                mat ATmp = *A[*it][j] + (vA * vA.t());\n                                double var = sumOfSquares[*it][j] + (points.at(j, i) * points.at(j, i));\n                                if (var < 0.0) {\n                                    printf(\"%lf - AMIGA !!! !!! !!!\\n\", var);\n                                }\n                                var -= ((vec)(2.0 * x.t() * bTmp))[0];\n                                var += ((mat)(x.t() * ATmp * x)).at(0, 0);\n                                var /= (card[*it] + 1);\n\n                                double prob = (card[*it] + 1.0) / pointsNum;\n                                double EIncl = prob * (-log(prob) + (0.5 * ((dim * log(2.0 * M_PI * M_E)) + log(det * det * var))));\n                                if (!is_finite(EIncl)) throw \"A numerical overflow occurred. BABA JAGA\";\n                                if (EIncl - E[*it] < dEMinIncl) {\n                                    dEMinIncl = EIncl - E[*it];\n                                    bestClIncl = *it;\n                                    bestAxisIncl = j;\n                                    EMinIncl = EIncl;\n                                    bestCoeffsIncl = x;\n                                    bestVarIncl = var;\n                                }\n\n                                if (j < dim - 1) v[j] = (points.at(j, i) - (*m[*it])[j]) / sqrt(card[*it] + 1);\n                            }\n\n                        }\n                    }\n                    if (dEMinExcl + dEMinIncl < 0.0) {\n                        vec v = (points.submat(1, i, size(dim - 1, 1)) - m[cl]->subvec(1, dim - 1)) / sqrt(card[cl] - 1);\n                        for (int j = 0; j < dim; ++j) {\n                            vec vTmp = v;\n                            CholeskyRankOneDowndate(*sigmaL[cl][j], vTmp);\n                            *sigmaL[cl][j] *= sqrt(card[cl] / (card[cl] - 1.0));\n\n                            vec vA = values.submat(j * dimA, i, size(dimA, 1));\n                            vec vATmp = vA;\n                            CholeskyRankOneDowndate(*AL[cl][j], vATmp);\n                            *b[cl][j] -= points.at(j, i) * vA;\n                            *A[cl][j] -= (vA * vA.t());\n\n                            sumOfSquares[cl][j] -= points.at(j, i) * points.at(j, i);\n\n                            if (j < dim - 1) v[j] = (points.at(j, i) - (*m[cl])[j]) / sqrt(card[cl] - 1);\n                        }\n                        v = (points.submat(1, i, size(dim - 1, 1)) - m[bestClIncl]->subvec(1, dim - 1)) / sqrt(card[bestClIncl] + 1);\n                        for (int j = 0; j < dim; ++j) {\n                            vec vTmp = v;\n                            CholeskyRankOneUpdate(*sigmaL[bestClIncl][j], vTmp);\n                            *sigmaL[bestClIncl][j] *= sqrt(card[bestClIncl] / (card[bestClIncl] + 1.0));\n\n                            vec vA = values.submat(j * dimA, i, size(dimA, 1));\n                            vec vATmp = vA;\n                            CholeskyRankOneUpdate(*AL[bestClIncl][j], vATmp);\n                            *b[bestClIncl][j] += points.at(j, i) * vA;\n                            *A[bestClIncl][j] += (vA * vA.t());\n\n                            sumOfSquares[bestClIncl][j] += points.at(j, i) * points.at(j, i); //Byo: sumOfSquares[cl][j] += points.at(j, i) * points.at(j, i);\n\n                            if (j < dim - 1) v[j] = (points.at(j, i) - (*m[bestClIncl])[j]) / sqrt(card[bestClIncl] + 1);\n                        }\n                        *m[cl] = ((*m[cl] * card[cl]) - points.col(i)) / (card[cl] - 1.0);\n                        *m[bestClIncl] = ((*m[bestClIncl] * card[bestClIncl]) + points.col(i)) / (card[bestClIncl] + 1.0);\n                        bestAxes[cl] = bestAxisExcl;\n                        bestAxes[bestClIncl] = bestAxisIncl;\n                        E[cl] = EMinExcl;\n                        E[bestClIncl] = EMinIncl;\n                        --card[cl];\n                        ++card[bestClIncl];\n                        labels[i] = bestClIncl;\n                        variances[cl] = bestVarExcl;\n                        variances[bestClIncl] = bestVarIncl;\n                        *coeffs[cl] = bestCoeffsExcl;\n                        *coeffs[bestClIncl] = bestCoeffsIncl;\n                        if (((double)card[cl]) / pointsNum < cardMin) {\n                            inactiveClusters.insert(cl);\n                            activeClusters.erase(cl);\n                        }\n                    } else {\n                        //printf(\"BO: %.25lf\\n\", dEMinExcl + dEMinIncl);\n                    }\n                }\n            }\n\n            //   -*-   -*-   -*-\n\n            for (std::set<int>::iterator it1 = inactiveClusters.begin(); it1 != inactiveClusters.end(); ++it1) {\n                printf(\"WYWALANIE Z KLASTRA: %d\\n\", *it1); // !!!\n\n                for (int j = 0; j < pointsNum; ++j) {\n                    int cl = labels[j];\n                    if (*it1 == cl) {\n                        double dEMinIncl = INFINITY;\n                        int bestClIncl;\n                        int bestAxisIncl;\n                        double EMinIncl;\n                        vec bestCoeffsIncl;\n                        double bestVarIncl;\n\n                        for (std::set<int>::iterator it2 = activeClusters.begin(); it2 != activeClusters.end(); ++it2) {\n                            vec v = (points.submat(1, j, size(dim - 1, 1)) - m[*it2]->subvec(1, dim - 1)) / sqrt(card[*it2] + 1);\n                            for (int k = 0; k < dim; ++k) {\n                                mat sigmaLTmp = *sigmaL[*it2][k];\n                                vec vTmp = v;\n                                CholeskyRankOneUpdate(sigmaLTmp, vTmp);\n                                sigmaLTmp *= sqrt(card[*it2] / (card[*it2] + 1.0));\n                                double det = 1.0;\n                                for (int l = 0; l < dim - 1; ++l) det *= sigmaLTmp.at(l, l);\n\n                                mat ALTmp = *AL[*it2][k];\n                                vec vA = values.submat(k * dimA, j, size(dimA, 1));\n                                vec vATmp = vA;\n                                CholeskyRankOneUpdate(ALTmp, vATmp);\n                                vec bTmp = *b[*it2][k] + (points.at(k, j) * vA);\n                                vec y = solve(trimatl(ALTmp), bTmp);\n                                vec x = solve(trimatu(ALTmp.t()), y);\n                                mat ATmp = *A[*it2][k] + (vA * vA.t());\n                                double var = sumOfSquares[*it2][k] + (points.at(k, j) * points.at(k, j));\n                                var -= ((vec)(2.0 * x.t() * bTmp))[0];\n                                var += ((mat)(x.t() * ATmp * x)).at(0, 0);\n                                var /= (card[*it2] + 1);\n\n                                double prob = (card[*it2] + 1.0) / pointsNum;\n                                double EIncl = prob * (-log(prob) + (0.5 * ((dim * log(2.0 * M_PI * M_E)) + log(det * det * var))));\n                                if (!is_finite(EIncl)) throw \"A numerical overflow occurred. JAJCO!\";\n                                if (EIncl - E[*it2] < dEMinIncl) {\n                                    dEMinIncl = EIncl - E[*it2];\n                                    bestClIncl = *it2;\n                                    bestAxisIncl = k;\n                                    EMinIncl = EIncl;\n                                    bestCoeffsIncl = x;\n                                    bestVarIncl = var;\n                                }\n\n                                if (k < dim - 1) v[k] = (points.at(k, j) - (*m[*it2])[k]) / sqrt(card[*it2] + 1);\n                            }\n                        }\n                        if (dEMinIncl < INFINITY) {\n                            vec v = (points.submat(1, j, size(dim - 1, 1)) - m[bestClIncl]->subvec(1, dim - 1)) / sqrt(card[bestClIncl] + 1);\n                            for (int k = 0; k < dim; ++k) {\n                                vec vTmp = v;\n                                CholeskyRankOneUpdate(*sigmaL[bestClIncl][k], vTmp);\n                                *sigmaL[bestClIncl][k] *= sqrt(card[bestClIncl] / (card[bestClIncl] + 1.0));\n\n                                vec vA = values.submat(k * dimA, j, size(dimA, 1));\n                                vec vATmp = vA;\n                                CholeskyRankOneUpdate(*AL[bestClIncl][k], vATmp);\n                                *b[bestClIncl][k] += points.at(k, j) * vA;\n                                *A[bestClIncl][k] += (vA * vA.t());\n\n                                sumOfSquares[bestClIncl][k] += points.at(k, j) * points.at(k, j);\n\n                                if (k < dim - 1) v[k] = (points.at(k, j) - (*m[bestClIncl])[k]) / sqrt(card[bestClIncl] + 1);\n                            }\n                            *m[bestClIncl] = ((*m[bestClIncl] * card[bestClIncl]) + points.col(j)) / (card[bestClIncl] + 1.0);\n                            bestAxes[bestClIncl] = bestAxisIncl;\n                            E[bestClIncl] = EMinIncl;\n                            ++card[bestClIncl];\n                            labels[j] = bestClIncl;\n                            *coeffs[bestClIncl] = bestCoeffsIncl;\n                            variances[bestClIncl] = bestVarIncl;\n                        }\n                    }\n                }\n            }\n            inactiveClusters.clear();\n\n        }\n        ETotalNew = 0.0;\n        for (std::set<int>::iterator it = activeClusters.begin(); it != activeClusters.end(); ++it) ETotalNew += E[*it];\n        if (!is_finite(ETotalNew)) throw \"A numerical overflow occurred.\";\n\n        printf(\"%d: %.10lf\\n\", numberOfIterations, ETotalNew); // !!!\n\n        if (interactive) {\n            Rcpp::List cardL(maxClusters);\n            Rcpp::List mL(maxClusters);\n            Rcpp::List covL(maxClusters);\n            Rcpp::List GLMDesignMatrixL(maxClusters); // !!!\n            Rcpp::List GLMResponseVectorL(maxClusters); // !!!\n            Rcpp::List coeffsL(maxClusters);\n            Rcpp::List dirsL(maxClusters);\n            Rcpp::List EL(maxClusters); // !!!\n            for (int i = 0; i < maxClusters; ++i) {\n                if (activeClusters.find(i) != activeClusters.end()) {\n                    uvec ind(dim - 1);\n                    for (int j = 0; j < bestAxes[i]; ++j) ind(j) = j;\n                    for (int j = bestAxes[i] + 1; j < dim; ++j) ind(j - 1) = j;\n\n                    (*sigma[i])(bestAxes[i], span::all).fill(0.0);\n                    (*sigma[i])(span::all, bestAxes[i]).fill(0.0);\n                    (*sigma[i])(bestAxes[i], bestAxes[i]) = variances[i];\n                    sigma[i]->submat(ind, ind) = *sigmaL[i][bestAxes[i]] * sigmaL[i][bestAxes[i]]->t();\n\n                    cardL[i] = card[i];\n                    mL[i] = *m[i];\n                    covL[i] = *sigma[i];\n\n                    // !!!\n                    Rcpp::List tmp1(dim);\n                    Rcpp::List tmp2(dim);\n                    for (int j = 0; j < dim; ++j) {\n                        tmp1[j] = *A[i][j];\n                        tmp2[j] = *b[i][j];\n                    }\n                    GLMDesignMatrixL[i] = tmp1;\n                    GLMResponseVectorL[i] = tmp2;\n                    // !!!\n\n                    coeffsL[i] = *coeffs[i];\n                    dirsL[i] = bestAxes[i];\n                    EL[i] = E[i]; // !!!\n                } else {\n                    cardL[i] = 0;\n                    mL[i] = R_NilValue;\n                    covL[i] = R_NilValue;\n                    GLMDesignMatrixL[i] = R_NilValue; // !!!\n                    GLMResponseVectorL[i] = R_NilValue; // !!!\n                    coeffsL[i] = R_NilValue;\n                    dirsL[i] = R_NilValue;\n                    EL[i] = R_NilValue; // !!!\n                }\n            }\n            res.push_back(Rcpp::List::create(\n                Rcpp::Named(\"cardinalities\", cardL),\n                Rcpp::Named(\"number_of_clusters\", (int)activeClusters.size()),\n                Rcpp::Named(\"labels\", labels),\n                Rcpp::Named(\"means\", mL),\n                Rcpp::Named(\"covariances\", covL),\n                Rcpp::Named(\"GLM_design_matrix\", GLMDesignMatrixL), // !!!\n                Rcpp::Named(\"GLM_response_vector\", GLMResponseVectorL), // !!!\n                Rcpp::Named(\"coefficients\", coeffsL),\n                Rcpp::Named(\"directions\", dirsL),\n                Rcpp::Named(\"cost_total\", ETotalNew),\n                Rcpp::Named(\"cost\", EL) // !!!\n            ));\n        }\n\n        ++numberOfIterations;\n    } while ((numberOfIterations < minIterations) || ((numberOfIterations < maxIterations) && (ETotalNew - ETotalOld < dETotalThreshold)));\n\n    if (numberOfIterations < 2) printf(\"YABADABADOO!\\n\"); // !!!\n\n    //   -*-   -*-   -*-\n\n    if (!interactive) {\n        Rcpp::List cardL(maxClusters);\n        Rcpp::List mL(maxClusters);\n        Rcpp::List covL(maxClusters);\n        Rcpp::List GLMDesignMatrixL(maxClusters); // !!!\n        Rcpp::List GLMResponseVectorL(maxClusters); // !!!\n        Rcpp::List coeffsL(maxClusters);\n        Rcpp::List dirsL(maxClusters);\n        Rcpp::List EL(maxClusters); // !!!\n        for (int i = 0; i < maxClusters; ++i) {\n            if (activeClusters.find(i) != activeClusters.end()) {\n                uvec ind(dim - 1);\n                for (int j = 0; j < bestAxes[i]; ++j) ind(j) = j;\n                for (int j = bestAxes[i] + 1; j < dim; ++j) ind(j - 1) = j;\n\n                (*sigma[i])(bestAxes[i], span::all).fill(0.0);\n                (*sigma[i])(span::all, bestAxes[i]).fill(0.0);\n                (*sigma[i])(bestAxes[i], bestAxes[i]) = variances[i];\n                sigma[i]->submat(ind, ind) = *sigmaL[i][bestAxes[i]] * sigmaL[i][bestAxes[i]]->t();\n\n                cardL[i] = card[i];\n                mL[i] = *m[i];\n                covL[i] = *sigma[i];\n\n                // !!!\n                Rcpp::List tmp1(dim);\n                Rcpp::List tmp2(dim);\n                for (int j = 0; j < dim; ++j) {\n                    tmp1[j] = *A[i][j];\n                    tmp2[j] = *b[i][j];\n                }\n                GLMDesignMatrixL[i] = tmp1;\n                GLMResponseVectorL[i] = tmp2;\n                // !!!\n\n                coeffsL[i] = *coeffs[i];\n                dirsL[i] = bestAxes[i];\n                EL[i] = E[i]; // !!!\n            } else {\n                cardL[i] = 0;\n                mL[i] = R_NilValue;\n                covL[i] = R_NilValue;\n                GLMDesignMatrixL[i] = R_NilValue; // !!!\n                GLMResponseVectorL[i] = R_NilValue; // !!!\n                coeffsL[i] = R_NilValue;\n                dirsL[i] = R_NilValue;\n                EL[i] = R_NilValue; // !!!\n            }\n        }\n        res = Rcpp::List::create(\n            Rcpp::Named(\"cardinalities\", cardL),\n            Rcpp::Named(\"number_of_clusters\", (int)activeClusters.size()),\n            Rcpp::Named(\"labels\", labels),\n            Rcpp::Named(\"means\", mL),\n            Rcpp::Named(\"covariances\", covL),\n            Rcpp::Named(\"GLM_design_matrix\", GLMDesignMatrixL), // !!!\n            Rcpp::Named(\"GLM_response_vector\", GLMResponseVectorL), // !!!\n            Rcpp::Named(\"coefficients\", coeffsL),\n            Rcpp::Named(\"directions\", dirsL),\n            Rcpp::Named(\"cost_total\", ETotalNew),\n            Rcpp::Named(\"cost\", EL) // !!!\n        );\n    }\n    return res;\n}\n\n//   -*-   -*-   -*-\n\n// [[Rcpp::export]]\nRcpp::List afCECCppRoutine (\n    const arma::mat &points,\n    int maxClusters,\n    const SEXP &initialLabels,\n    double cardMin,\n    int minIterations,\n    int maxIterations,\n    int numberOfStarts,\n    const std::string &method,\n    const arma::mat &values,\n    bool interactive\n) try {\n    int pointsNum = points.n_cols;\n    int dim = points.n_rows;\n\n    if (dim < 2) throw \"The points have to be of the dimension at least 2.\";\n\n    if (maxClusters < 1) throw \"The maximum number of clusters should be a positive value.\";\n    if (maxClusters > pointsNum) throw \"The maximum number of clusters cannot exceed the number of points.\";\n\n    if (numberOfStarts < 1) throw \"The number of starts should be a positive value.\";\n\n    std::string initialLabelsStr;\n    imat initialLabelsMat;\n    try {\n        switch (TYPEOF(initialLabels)) {\n            case STRSXP : {\n                initialLabelsStr = Rcpp::as<std::string>(initialLabels);\n                if ((initialLabelsStr != \"random\") && (initialLabelsStr != \"k-means++\"))\n                    throw \"The initialLabels parameter as a string directive should take a value of either \\\"random\\\" or \\\"k-means++\\\".\";\n                break;\n            }\n            case INTSXP : {\n                if (numberOfStarts == 1) {\n                    ivec initialLabelsVec = Rcpp::as<ivec>(initialLabels);\n                    initialLabelsMat = imat(initialLabelsVec);\n                } else\n                    initialLabelsMat = Rcpp::as<imat>(initialLabels);\n                if ((initialLabelsMat.n_rows != pointsNum) || (initialLabelsMat.n_cols != numberOfStarts))\n                    throw \"The initialLabels parameter as a matrix should be of the dimensions (number of points x number of starts).\";\n                for (int i = 0; i < initialLabelsMat.n_rows; ++i) {\n                    for (int j = 0; j < initialLabelsMat.n_cols; ++j) {\n                        if ((initialLabelsMat.at(i, j) < 0) || (initialLabelsMat.at(i, j) >= maxClusters))\n                            throw \"The initialLabels parameter as a matrix should have elements of the range [0, maxClusters - 1].\";\n                    }\n                }\n                break;\n            }\n            default : {\n                throw \"The initialLabels parameter should be either a string directive or a matrix of the type integer.\";\n            }\n        }\n    } catch (std::bad_alloc &e) {\n        throw \"Not enough memory.\";\n    } catch (std::exception &e) {\n        printf(e.what());\n        throw \"The initialLabels parameter should be either a string directive or a matrix of the type integer.\";\n    }\n\n    if (maxIterations < 0)\n        throw \"The maximum number of iterations should be a non-negative value.\";\n    if ((method != \"Lloyd\") && (method != \"Hartigan\"))\n        throw \"The method parameter should take a value of either \\\"Lloyd\\\" or \\\"Hartigan\\\".\";\n\n    ivec labels(pointsNum);\n    double EMin = INFINITY;\n    Rcpp::List bestRes;\n    for (int i = 0; i < numberOfStarts; ++i) {\n        try {\n            switch (TYPEOF(initialLabels)) {\n                case STRSXP : {\n                    if (initialLabelsStr == \"random\") {\n                        //for (int j = 0; j < pointsNum; ++j) labels[j] = (RandomInteger() & 2147483647) % maxClusters;\n                        for (int j = 0; j < pointsNum; ++j) labels[j] = rand() % maxClusters;\n                    } else {\n                        // We perform the k-means++ algorithm.\n                        mat centers(dim, maxClusters);\n                        vec cdf(pointsNum);\n                        centers.col(0) = points.col((RandomInteger() & 2147483647) % pointsNum);\n                        for (int j = 1; j < maxClusters; ++j) {\n                            for (int k = 0; k < pointsNum; ++k) {\n                                vec p = points.col(k);\n                                double dMin = INFINITY;\n                                for (int l = 0; l < j; ++l) {\n                                    double d = norm(p - centers.col(l));\n                                    if (d < dMin) dMin = d;\n                                }\n                                if (k == 0) cdf[k] = dMin * dMin;\n                                else\n                                    cdf[k] = cdf[k - 1] + (dMin * dMin);\n                            }\n                            cdf /= cdf[pointsNum - 1];\n                            if (!cdf.is_finite()) throw \"A numerical overflow occurred.\";\n                            // In order to apply the inverse transform sampling we have to generate an uniformly distributed\n                            // pseudorandom value belonging to the interval (0, 1).\n                            double value = RandomFloat();\n                            // If the generated value is equal to 0, we generate it one more time. In the next step we are\n                            // guaranteed to get a value different than 0.\n                            if (value == 0.0) value = RandomFloat();\n                            // We apply the inverse transform sampling.\n                            int lB = 0;\n                            int uB = pointsNum - 1;\n                            while (uB > lB) {\n                                int pivot = (lB + uB) >> 1;\n                                if (value <= cdf[pivot]) uB = pivot;\n                                else\n                                    lB = pivot + 1;\n                            }\n                            centers.col(j) = points.col(lB);\n                        }\n                        for (int j = 0; j < pointsNum; ++j) {\n                            vec p = points.col(j);\n                            double dMin = INFINITY;\n                            int dMinInd;\n                            for (int k = 0; k < maxClusters; ++k) {\n                                double d = norm(p - centers.col(k));\n                                if (d < dMin) {\n                                    dMin = d;\n                                    dMinInd = k;\n                                }\n                            }\n                            if (is_finite(dMin)) labels[j] = dMinInd;\n                            else\n                                throw \"A numerical overflow occurred.\";\n                        }\n                    }\n                    break;\n                }\n                case INTSXP : {\n                    labels = initialLabelsMat.col(i);\n                    break;\n                }\n            }\n            Rcpp::List res;\n            if (method == \"Lloyd\") res = afCECLloyd(points, maxClusters, labels, cardMin, minIterations, maxIterations, values, interactive);\n            else {\n                res = afCECHartigan(points, maxClusters, labels, cardMin, minIterations, maxIterations, values, interactive);\n\n                //CafCECHartigan afCECHartigan(points, maxClusters, labels, cardMin, minIterations, maxIterations, 0.0, values, interactive);\n                //res = afCECHartigan.res;\n            }\n            if (res.length() > 0) {\n                if (!interactive) {\n                    double E = res[\"cost_total\"];\n                    printf(\":::::::: %lf\\n\", E); // !!!\n                    if (E < EMin) {\n                        EMin = E;\n                        bestRes = res;\n                    }\n                } else {\n                    Rcpp::List tmp = res[res.length() - 1];\n                    double E = tmp[\"cost_total\"];\n                    printf(\":::::::: %lf\\n\", E); // !!!\n                    if (E < EMin) {\n                        EMin = E;\n                        bestRes = res;\n                    }\n                }\n            }\n        } catch (mat &m) {\n            if (!bestRes.containsElementNamed(\"badCl\")) bestRes[\"badCl\"] = m;\n        } catch (std::bad_alloc &e) {\n            if (printErrorMessages) printf(\"(Start %d): Not enough memory.\\n\", i);\n        } catch (const char *e) {\n            if (printErrorMessages) printf(\"(Start %d): %s\\n\", i, e);\n        } catch (...) {\n            if (printErrorMessages) printf(\"(Start %d): An unknown error occurred.\\n\", i);\n        }\n    }\n\n    //if (EMin == INFINITY) throw \"A clustering hasn't been found during any of the starts.\";\n    return bestRes;\n} catch (const char *e) {\n    if (printErrorMessages) printf(\"%s\\n\", e);\n    return Rcpp::List();\n} catch (...) {\n    if (printErrorMessages) printf(\"An unknown error occurred.\\n\");\n    return Rcpp::List();\n}\n\n//   -*-   -*-   -*-\n\n// [[Rcpp::export]]\ndouble RandIndex(std::vector<int> labels1, std::vector<int> labels2, int maxClusters1, int maxClusters2) {\n    int n = labels1.size();\n\n    int *clustersMap = new int[maxClusters1];\n    bool *clustersOccurrence = new bool[maxClusters1];\n    for (int i = 0; i < maxClusters1; ++i) clustersOccurrence[i] = false;\n    int activeClustersNum1 = 0;\n    for (int i = 0; i < n; ++i) {\n        int cl = labels1[i];\n        if (!clustersOccurrence[cl]) {\n            labels1[i] = activeClustersNum1;\n            clustersMap[cl] = activeClustersNum1++;\n            clustersOccurrence[cl] = true;\n        } else\n            labels1[i] = clustersMap[cl];\n    }\n    delete[] clustersMap;\n    delete[] clustersOccurrence;\n\n    clustersMap = new int[maxClusters2];\n    clustersOccurrence = new bool[maxClusters2];\n    for (int i = 0; i < maxClusters2; ++i) clustersOccurrence[i] = false;\n    int activeClustersNum2 = 0;\n    for (int i = 0; i < n; ++i) {\n        int cl = labels2[i];\n        if (!clustersOccurrence[cl]) {\n            labels2[i] = activeClustersNum2;\n            clustersMap[cl] = activeClustersNum2++;\n            clustersOccurrence[cl] = true;\n        } else\n            labels2[i] = clustersMap[cl];\n    }\n    delete[] clustersMap;\n    delete[] clustersOccurrence;\n\n    int *clustersCard1 = new int[activeClustersNum1];\n    int *clustersCard2 = new int[activeClustersNum2];\n    for (int i = 0; i < activeClustersNum1; ++i) clustersCard1[i] = 0;\n    for (int i = 0; i < activeClustersNum2; ++i) clustersCard2[i] = 0;\n    for (int i = 0; i < n; ++i) {\n        ++clustersCard1[labels1[i]];\n        ++clustersCard2[labels2[i]];\n    }\n\n    int **clusters1 = new int*[activeClustersNum1];\n    for (int i = 0; i < activeClustersNum1; ++i) clusters1[i] = new int[clustersCard1[i]];\n    for (int i = 0; i < activeClustersNum1; ++i) clustersCard1[i] = 0;\n    for (int i = 0; i < n; ++i) {\n        int cl = labels1[i];\n        clusters1[cl][clustersCard1[cl]++] = i;\n    }\n\n    long long TP = 0;\n    long long TN = 0;\n    int *classesMap = new int[activeClustersNum2];\n    int *classesInvMap = new int[activeClustersNum2];\n    bool *classesOccurrence = new bool[activeClustersNum2];\n    for (int i = 0; i < activeClustersNum2; ++i) classesOccurrence[i] = false;\n    int *classesCard = new int[activeClustersNum2];\n    for (int i = 0; i < activeClustersNum1; ++i) {\n        int classesNum = 0;\n        for (int j = 0; j < clustersCard1[i]; ++j) {\n            int ind = clusters1[i][j];\n            int cl = labels2[ind];\n            if (!classesOccurrence[cl]) {\n                classesCard[classesNum] = 1;\n                classesMap[cl] = classesNum;\n                classesInvMap[classesNum++] = cl;\n                classesOccurrence[cl] = true;\n            } else\n                ++classesCard[classesMap[cl]];\n        }\n\n        for (int j = 0; j < classesNum; ++j) {\n            if (classesCard[j] >= 2) TP += (((long long)classesCard[j]) * (classesCard[j] - 1)) / 2;\n            TN += ((long long)classesCard[j]) * (n - clustersCard1[i] - clustersCard2[classesInvMap[j]] + classesCard[j]);\n        }\n\n        for (int j = 0; j < clustersCard1[i]; ++j) {\n            int ind = clusters1[i][j];\n            int cl = labels2[ind];\n            classesOccurrence[cl] = false;\n        }\n    }\n    TN = TN / 2;\n\n    for (int i = 0; i < activeClustersNum1; ++i) delete[] clusters1[i];\n    delete[] clusters1;\n    delete[] classesMap;\n    delete[] classesInvMap;\n    delete[] classesOccurrence;\n    delete[] classesCard;\n\n    printf(\"%I64d %I64d\\n\", TP, TN); // !!!\n\n    return ((double)(TP + TN)) / ((((long long)n) * (n - 1)) / 2);\n}\n\n//   -*-   -*-   -*-\n\n// [[Rcpp::export]]\ndouble JaccardIndex(std::vector<int> labels1, std::vector<int> labels2, int maxClusters1, int maxClusters2) {\n    int n = labels1.size();\n\n    int *clustersMap = new int[maxClusters1];\n    bool *clustersOccurrence = new bool[maxClusters1];\n    for (int i = 0; i < maxClusters1; ++i) clustersOccurrence[i] = false;\n    int activeClustersNum1 = 0;\n    for (int i = 0; i < n; ++i) {\n        int cl = labels1[i];\n        if (!clustersOccurrence[cl]) {\n            labels1[i] = activeClustersNum1;\n            clustersMap[cl] = activeClustersNum1++;\n            clustersOccurrence[cl] = true;\n        } else\n            labels1[i] = clustersMap[cl];\n    }\n    delete[] clustersMap;\n    delete[] clustersOccurrence;\n\n    clustersMap = new int[maxClusters2];\n    clustersOccurrence = new bool[maxClusters2];\n    for (int i = 0; i < maxClusters2; ++i) clustersOccurrence[i] = false;\n    int activeClustersNum2 = 0;\n    for (int i = 0; i < n; ++i) {\n        int cl = labels2[i];\n        if (!clustersOccurrence[cl]) {\n            labels2[i] = activeClustersNum2;\n            clustersMap[cl] = activeClustersNum2++;\n            clustersOccurrence[cl] = true;\n        } else\n            labels2[i] = clustersMap[cl];\n    }\n    delete[] clustersMap;\n    delete[] clustersOccurrence;\n\n    int *clustersCard1 = new int[activeClustersNum1];\n    int *clustersCard2 = new int[activeClustersNum2];\n    for (int i = 0; i < activeClustersNum1; ++i) clustersCard1[i] = 0;\n    for (int i = 0; i < activeClustersNum2; ++i) clustersCard2[i] = 0;\n    for (int i = 0; i < n; ++i) {\n        ++clustersCard1[labels1[i]];\n        ++clustersCard2[labels2[i]];\n    }\n\n    int **clusters1 = new int*[activeClustersNum1];\n    for (int i = 0; i < activeClustersNum1; ++i) clusters1[i] = new int[clustersCard1[i]];\n    for (int i = 0; i < activeClustersNum1; ++i) clustersCard1[i] = 0;\n    for (int i = 0; i < n; ++i) {\n        int cl = labels1[i];\n        clusters1[cl][clustersCard1[cl]++] = i;\n    }\n\n    long long TP = 0;\n    long long TN = 0;\n    int *classesMap = new int[activeClustersNum2];\n    int *classesInvMap = new int[activeClustersNum2];\n    bool *classesOccurrence = new bool[activeClustersNum2];\n    for (int i = 0; i < activeClustersNum2; ++i) classesOccurrence[i] = false;\n    int *classesCard = new int[activeClustersNum2];\n    for (int i = 0; i < activeClustersNum1; ++i) {\n        int classesNum = 0;\n        for (int j = 0; j < clustersCard1[i]; ++j) {\n            int ind = clusters1[i][j];\n            int cl = labels2[ind];\n            if (!classesOccurrence[cl]) {\n                classesCard[classesNum] = 1;\n                classesMap[cl] = classesNum;\n                classesInvMap[classesNum++] = cl;\n                classesOccurrence[cl] = true;\n            } else\n                ++classesCard[classesMap[cl]];\n        }\n\n        for (int j = 0; j < classesNum; ++j) {\n            if (classesCard[j] >= 2) TP += (((long long)classesCard[j]) * (classesCard[j] - 1)) / 2;\n            TN += ((long long)classesCard[j]) * (n - clustersCard1[i] - clustersCard2[classesInvMap[j]] + classesCard[j]);\n        }\n\n        for (int j = 0; j < clustersCard1[i]; ++j) {\n            int ind = clusters1[i][j];\n            int cl = labels2[ind];\n            classesOccurrence[cl] = false;\n        }\n    }\n    TN = TN / 2;\n\n    for (int i = 0; i < activeClustersNum1; ++i) delete[] clusters1[i];\n    delete[] clusters1;\n    delete[] classesMap;\n    delete[] classesInvMap;\n    delete[] classesOccurrence;\n    delete[] classesCard;\n\n    printf(\"%I64d %I64d\\n\", TP, TN); // !!!\n\n    return ((double)TP) / (((((long long)n) * (n - 1)) / 2) - TN);\n}\n",
    "created" : 1493948880538.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "2937973156",
    "id" : "D3CBFA72",
    "lastKnownWriteTime" : 1501651827,
    "path" : "~/afCEC/src/afCEC.cpp",
    "project_path" : "src/afCEC.cpp",
    "properties" : {
    },
    "relative_order" : 1,
    "source_on_save" : false,
    "type" : "cpp"
}